<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>MiniApp Standardization White Paper</title>

    <style>
    .two-cols {
      display: grid;
      grid-template-columns: 1fr 1fr;
    }

    table {
      border-collapse:collapse;
    }

    table,th, td {
      border: 1px solid #666;
    }

    td {
      padding:2px 15px;
    }
    </style>

    <script async class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>

    <script class="remove">
        var respecConfig = {
            specStatus: "ED",
            previousPublishDate: "2019-09-12",
            previousMaturity: "WD",
            copyrightStart: "2019",
            edDraftURI: "https://w3c.github.io/mini-app-white-paper/",

            shortName: "mini-app-white-paper",
            noRecTrack: true,
            copyrightStart: "2019",

            editors: [{
                name: "Anqi Li",
                companyURL: "http://www.alibabagroup.com/en/global/home",
                company: "Alibaba"
              }, {
                name: "Qing An",
                companyURL: "http://www.alibabagroup.com/en/global/home",
                company: "Alibaba"
              }, {
                name: "Dapeng Liu",
                companyURL: "http://www.alibabagroup.com/en/global/home",
                company: "Alibaba"
              }, {
                name: "Hongru Zhu",
                companyURL: "http://www.alibabagroup.com/en/global/home",
                company: "Alibaba"
              }, {
                name: "Qingqian Tao",
                companyURL: "http://www.baidu.com/",
                company: "Baidu, Inc"
              }, {
                name: "Zhixing Lei",
                companyURL: "http://www.baidu.com/",
                company: "Baidu, Inc"
              }, {
                name: "Dan Zhou",
                companyURL: "http://www.baidu.com/",
                company: "Baidu, Inc"
              }, {
                name: "Zhiqiang Yu",
                companyURL: "http://www.huawei.com/",
                company: "Huawei"
              }, {
                name: "Wanming Lin",
                companyURL: "http://www.intel.com/",
                company: "Intel Corporation"
              }, {
                name: "Kaining Yuan",
                companyURL: "http://www.intel.com/",
                company: "Intel Corporation"
              }, {
                name: "Yinlin Chen",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi"
              }, {
                name: "Xiaowei Jiang",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi"
              }, {
                name: "Fuqiao Xue",
                companyURL: "https://www.w3.org/",
                company: "W3C"
              }, {
                name: "Lei Zhao",
                companyURL: "http://www.10086.cn/",
                company: "China Mobile"
              }],

            wg: "Chinese Web Interest Group",
            wgURI: "https://www.w3.org/2018/chinese-web-ig/",
            wgPublicList: "public-chinese-web",

            github: "w3c/mini-app-white-paper",

            wgPatentURI: "https://www.w3.org/2004/01/pp-impl/109611/status"
        };
    </script>
</head>

<body>
    <section id='abstract'>
        <p>
        This document introduces a new format for mobile application, named MiniApp, which is a very popular hybrid solution relying on Web technologies but also integrates with capabilities of Native Apps.
        </p>
    </section>
    <section id='sotd'>
        <p>
        This is still a work in progress. The proposal is being incubated in the <a href="https://w3c.github.io/chinese-ig/">W3C Chinese Web Interest Group</a>.
        </p>
    </section>

    <section>
        <h2>Introduction</h2>
        <section>
            <h2>Problems</h2>
            <p>Native Apps are well received in our daily life, but there are still many things that can be done better for users.</p>
            <ul>
                <li>
                    <p>Before a user get the service from a native app, he/she often have to go through the process to download -> install -> register the app.</p>
                    <p>User can only keep a limited number of Native Apps on their phone due to constraint of storage capability.</p>
                    <p>It's not easy to share data between different Native apps.</p>
                </li>
                <li>
                    <p>To work on a Native App, developers may need to learn a few new programming languages.</p>
                    <p>To provide the same service with Native Apps, developers may need to maintain duplicate products for different platforms.</p>
                </li>
            </ul>
            <p>The Web is an ideal platform to avoid these problems, but by far, it's still imperfect.</p>
            <ul>
                <li>
                    <p>Compared to the Native, it isn't easy to take advantage of the capabilities provided by the system. </p>
                    <p>Also, it's usually difficult to design a Web application whose performance can actually match or surpass a similar Native app.</p>
                </li>
                <li>
                    <p>On a mobile device, users obtain services or contents outside the browser very frequently, naturally, they would like all their applications to be consistent on user accounts, login status and user interaction across the whole system.</p>
                    <p>Moreover, sometimes users may want to share some data with an application if they really trust it, but for a few frequently requested information, such as personal mobile number of the current device, or the contact list, there isn't a good way for the users to give permits on the Web.</p>
                </li>
            </ul>
        </section>
        <section>
            <h2>What is MiniApp?</h2>
                <p>MiniApp is a new format of mobile application, a hybrid solution which relies on Web technologies (especially CSS and Javascript) but also integrates with capabilities of Native Apps.</p>
                <p>MiniApps got popular from their usage on a few super-apps, as it was born with a few characters that help to fill the gap of the Web and the Native.</p>
                <ul>
                    <li>It's free of installation.</li>
                    <li>Multiple webviews to improve performance.</li>
                    <li>It provides a few mechanisms to get access to OS capabilities or data through the Native.</li>
                    <li>The content is usually more trustworthy because the app needs to be validated by the platform.</li>
                    <li>A miniapp can be distributed to multiple MiniApp platforms (the Web, a Native App, even the OS). These platforms also provide entry to the miniapp to ensure it can be easily discovered by the users.</li>
                </ul>
            </section>
            <section>
                <h2>Can we just use PWA?</h2>
                <p>MiniApps are NOT aimed to replace PWA, or the Web, or the Native.</p>
                <ul>
                    <li>Goal
                        <dl>
                            <dt>PWA</dt>
                            <dd>Progressive Web Apps provide user experience that feels like the Native apps, especially with better support for offline and push APIs.</dd>
                            <dt>MiniApp</dt>
                            <dd>MiniApps try to provide seamless service by sharing data and capabilities within the Native Apps, the Web and the OS.</dd>
                        </dl>
                    </li>
                    <li>Host Environment
                        <dl>
                            <dt>PWA</dt>
                            <dd>The browser.</dd>
                            <dt>MiniApp</dt>
                            <dd>A platform with extra capabilities, compared to the Native Apps, the Web and the OS. It's easier to implement new APIs on this platform.</dd>
                        </dl>
                    </li>
                </ul>
            </section>
            <section>
                <h2>Case studies</h2>
                <section>
                    <h2>Case 1: Shared Bicycle Service</h2>
                    <p>The popularization of MiniApps helps to make the shared bike a seamless service instead of a cumbersome application.</p>
                    <div class="two-cols">
                    <ul>
                        <li>User chooses any of the miniapp platforms on their mobile device, which, is usually a super-app that he/she already logined;</li>
                        <li>User scans the QR-code label attached on a shared bicycle within the superapp;</li>
                        <li>The hosted-app will automatically navigate to the shared bicycle miniapp and unlocks the bicycle instantly;</li>
                        <li>Upon arrival, user locks the bike on the miniapp;</li>
                        <li>Transaction completes, a message of the payment detail is sent to the user.</li>
                    </ul>
                    <figure>
                      <img alt="Shared Bicycle Service" src="images/shared_bike.png" width="200">
                      <figcaption>
                        Shared Bicycle Service with MiniApp
                      </figcaption>
                    </figure>
                    </div>
                    <p>For users, miniapps can bring convenient from a few perspectives:</p>
                    <table>
                      <tbody><tr>
                        <th></th>
                        <th>the Web</th> 
                        <th>Native App</th>
                        <th>MiniApp</th> 
                      </tr>
                      <tr>
                        <td>Download/Install</td>
                        <td>No</td> 
                        <td>Yes</td>
                        <td>No</td> 
                      </tr>
                      <tr>
                        <td>Verified/Trusted</td>
                        <td>No</td> 
                        <td>Yes</td>
                        <td>Yes</td>
                      </tr>
                      <tr>
                        <td>Login/Register</td>
                        <td>Yes</td> 
                        <td>Yes</td>
                        <td>User permission</td>
                      </tr>
                      <tr>
                        <td>Payment</td>
                        <td>Send a payment request</td> 
                        <td>Register a credit card or navigate to another app</td>
                        <td>Complete within the hosted-app</td>
                      </tr>
                    </tbody></table>

                </section>

                <section>
                    <h2>Case 2: AR Zoo</h2>
                    <p>MiniApp developers can simply use HTML/CSS/Javascript as the programming language, but MiniApp is more flexible so it excels at quick development of complex features in daily work.</p>
                    <p>This MiniApp tries to build an AR zoo with AI technologies to recognise the animals. Developers can easily do that by adding a few components or APIs that provide access to the native capabilities or advance features, f.ex., Image Recognition, AR 3D Animal models rendering, a speech API to for speech synthesis, AR navigation provided by the map SDK.</p>
                    <p>MiniApps can be discovered by the search engines, by the MiniApp store in the hosted-app or by QR-code.
                    <figure>
                      <img alt="AR zoo" src="images/ar_zoo.png" width="600">
                      <figcaption>
                        AR Zoo MiniApp
                      </figcaption>
                    </figure>
                    <p>For the developers, the incentive to work on miniapps is very obvious.</p>
                    <table>
                      <tbody><tr>
                        <th></th>
                        <th>the Web</th> 
                        <th>Native App</th>
                        <th>MiniApp</th> 
                      </tr>
                      <tr>
                        <td>Discoverability</td>
                        <td>Search Engine</td> 
                        <td>App Store</td>
                        <td>Multiple: search engines + MiniApp store in the hosted-apps + QR-code</td> 
                      </tr>
                      <tr>
                        <td>Verified/Trusted</td>
                        <td>Still exploring</td> 
                        <td>by Native App stores</td>
                        <td>by host App platforms</td>
                      </tr>
                      <tr>
                        <td>Deploy/Reload</td>
                        <td>load/reload the webpage</td> 
                        <td>installed/reinstalled</td>
                        <td>load/reload as it's using a JS engine</td>
                      </tr>
                      <tr>
                        <td>Programming Language</td>
                        <td>Web programming language</td> 
                        <td>new/multi languages: iOS and Android at least</td>
                        <td>Web programming language</td>
                      </tr>
                      <tr>
                        <td>APIs/Components (AR, Image Recognition, Geolocation, Speech API)</td>
                        <td>very basic</td> 
                        <td>complex for web developers</td>
                        <td>very simple high-level APIs and components</td>
                      </tr>
                    </tbody></table>
                </section>

                <section>
                    <h2>Case 3: MiniApp for IoT</h2>
                    <p>One of the goals of MiniApp to connect information and services across different platforms, so it's ideal for IoT applications such as Smart Automotive, voice-control speaker and Smart TV.</p>
                    <p>Nowadays, it's possible to convert some MiniApps to adapt the vehicle screen and system, also, a few MiniApp vendors have built a MiniApp platform specially design for the vehicle system, to help distribute or upgrade applications to various of car model. This brings millions of Web developers to the Automotive application ecosystem.</p>
                    <p>These Automotive miniapps can service many user scenarios, including gas filling, car washing, Electronic Toll Collection, insurance, restaurant reservation, or entertainment. For example, when the system detects the remaining fuel is less than 20%, it can recommend to the owner a Gas Pumping MiniApp. The user can get the information of the nearest gas station and head there to complete the gas pumping including the payment within MiniApp, "refueling without getting off the vehicle".</p>
                    <figure>
                      <img alt="smart car" src="images/smart_cars.png" width="600">
                      <figcaption>
                        MiniApp for Smart Car(Gas Pumping App)
                      </figcaption>
                    </figure>
            </section>
            </section>
        </section>
            <section>
                <h2>MiniApp Overview</h2>
                <section>
                    <h2>Core Features</h2>
                    <section>
                        <h2>Separate the View Layer from the Logic Layer</h2>
                        <p>In a miniapp, the view layer is usually separated from the logic layer.</p>
                        <figure>
                          <img alt="logic layer and view layer" src="images/logic_view.png" width="400">
                          <figcaption>
                            General Architecture of MiniApp
                          </figcaption>
                        </figure>
                        <p>The View Layer is responsible for rendering MiniApp pages, including Web components rendering and native components rendering, which can be considered as hybrid rendering. For example, Web components rendering can be handled by WebView, but some of the Web components rendering aren't supported by WebView or have performance limitation, MiniApp also relies on some native components, such as map, video, etc.</p>
                        <p>Logic Layer is implemented with JS Worker. The Worker is responsible for MiniApp’s event processing, API calling and lifecycle management.</p>
                        <p>Extended native capabilities usually come from the hosting Native App or OS, including payment, file processing, scanning, phone call, etc. These capabilities are called through certain APIs. When a Mini App calls a native API, it transfers the API calling to Extended Native Capabilities for further processing via JS Bridge, and obtains the result from Extended Native Capabilities via JS Bridge.</p>
                        <figure>
                          <img alt="data flow of MiniApp when an API is called" src="images/data_flow.png" width="600">
                          <figcaption>
                            Data flow of MiniApp when an API is called
                          </figcaption>
                        </figure>
                        <p>Worker establishes connection for each Render, transferring the need-to-be-rendered data to render for further processing.</p>
                        <p>If an event is triggered by a component in a MiniApp page, this page’s Render will send the event to worker for further processing. At the same time, the Render will wait for the data sent from worker to re-render the MiniApp page.</p>
                        <p>The rendering can be considered as stateless, and all the states will be stored in the worker.</p>
                        <p>The benefits of separating the View Layer and the Logic Layer include:</p>
                        <ul>
                            <li>Very handy for data sharing and interaction among multiple MiniApp pages.</li>
                            <li>Having the same context within a lifecycle of MiniApp can provide a similar coding experience for those developers coming from native app developement background.</li>
                            <li>Separation and parallel implementation of Render and JS worker can prevent the situation where a JS execution impacts or slows down the page rendering, which can help enhance the performance of rendering.</li>
                        </ul>
                    </section>
                    <section id="api_and_component">
                        <h2>Rich APIs and Components</h2>
                        <p>MiniApp platform provides many components to help developers build a fancy UI, including basic components like View, Form, Image, and high-level component like Maps.</p>
                        <p>MiniApp venders also offer a number of APIs for developers to get access to capabilities of both the Web and the native, including basic APIs such as UI display APIs, Image API, and those advanced ones like Account API, Map API, Payment API.</p>
                        <p>APIs usually work together with components. When user clicks certain component on a MiniApp page, it will call the related API to complete user’s interaction and refresh the current MiniApp page if needed.</p>
                    </section>
                    <section id="constructor">
                        <h2>MiniApp Constructor</h2>
                        <p>In order to obtain similar user experiences to native apps, MiniApp resources are usually packaged together. After downloading and installing a MiniApp package, all static page templates/CSS/JavaScript files need to present app pages already exist on users' machines. These resources are always available without any redundant downloads until next update.</p>
                        <p>A MiniApp package is a compressed format (e.g. zip) archive, including:</p>
                            <ul>
                                <li>one configuration document, located at the root directory of the package. The config file should include:
                                    <ul>
                                        <li>general description of the entire MiniApp.</li>
                                        <li>description of pages and their corresponding paths, for the purpose of page locating and opening.</li>
                                    </ul></li>
                                    <li>one app-level logic file, containing JavaScript codes, deals with app-level lifecycle callbacks.</li>
                                    <li>one or multi page files, containing templates codes for page structure, CSS codes for page style, and JavaScript codes for page logic.</li>
                                    <li>support digital signature for validation.</li>
                            </ul>
                            <p>For the purpose of locating a specific MiniApp while searching and executing, a MiniApp must have a package name or an ID on the platform. An icon is also required for user recognization.</p>
                    </section>
                    <section>
                        <h2>MiniApp Widgets</h2>
                        <p>In addition to being presented in the form of an MiniApp page, MiniApp can also be displayed in the form of information fragment, that is, a MiniApp widget. In this form, developers can put their service and/or content to various host scenarios, called host environment, such as assistants, search page, etc.. This feature connects services of the MiniApp with the scenario, providing users with more convenience.</p>
                        <p>For example, when a user purchases a train ticket for trip, the MiniApp widget on smart assistant shows the train's latest status immediately. The user can click on this widget and jump to a full-screen MiniApp page for more detailed information.</p>
                        <figure>
                          <img alt="Widget from home screen to MiniApp" src="images/widget.png" width="600">
                          <figcaption>
                            Widget from home screen to MiniApp
                          </figcaption>
                        </figure>
                        <p>Same as MiniApp page, widget is also described by URI scheme. The host environment specifies the MiniApp package and the corresponding widget to be loaded through URI path, and passes data to the widget through URI query params. After the widget is loaded, it is displayed and rendered in the host environment. Data from the host and widget, as well as data from different widgets are isolated to ensure security and independence.</p>

                        <p>In many scenarios, a widget can open a MiniApp page for more complicated operations. In such cases, widgets often need to share data with its corresponding MiniApp, e.g. maintain a consistent login status. Therefore, the data of the widget and the MiniApp can be accessed from each side. In other word, MiniApp widget and page have same data access rights.</p>

                        <figure>
                          <img alt="widget interaction" src="images/widget_interaction.png" width="600">
                          <figcaption>
                            MiniApp widget interaction
                          </figcaption>
                        </figure>

                        <p>One of the goals of the widget is to let the user forget the traditional app concept and truly meet the user's needs in the form of service. So in addition to all app invocation paths, widgets can also be triggered by different methods on different scenarios, such as text keywords, voice analysis, picture recognition, scan code, event intent.</p>
                        <p>Note: Widget is implemented by Quick App in China market.</p>
                    </section>
                    <section>
                        <h2>Single-Instance, Multi-Entries</h2>
                        <p>There are multiple entrances to discover, open and access MiniApps. Unlike Web in multi WebView, only one instance will be created for the same MiniApp, so MiniApp keeps its status and data in a consistent manner globally. For example, after one user opens and logs in a MiniApp through the entrance of QR code for the first time, the user will remain logged in next time when the user returns from another entrance like MiniApp store.</p>
                        <p>The entries for MiniApps include, but not limit to:</p>
                        <ul>
                            <li>MiniApp store</li>
                            <li>Search Engine</li>
                            <li>Smart Assistant</li>
                            <li>QR code</li>
                            <li>SMS/text</li>
                            <li>Physical Object(with AI)</li>
                            <li>Browser</li>
                            <li>Calender items</li>
                            <li>Voice message(with AI)</li>
                        </ul>  
                    </section>
                    <section>
                        <h2>Performance and User Experience</h2>
                        <p>MiniApps try to improve their performance and user experience with a few mechanisms that have been proved to be effective through practice.
                        <dl>                            
                                <dt>Packaging</dt>
                                <dd><p>With <a href="#constructor">MiniApp's constructor</a>, user only needs to download the package when the MiniApp is first opened, and then the static resources(pages/JavaScript/CSS) in the MiniApp needn't be downloaded again, so that the loading and jumping of the following pages can be more quickly responded. This feature improves user operation experience and save network traffic.</p>
                                <p>Meanwhile, the MiniApp has a pre-download mechanism, which can download the MiniApp packages in advance, or pre-downloads separately for the first page, and perform streaming decompression in parallel during download to minimize the time-consuming of MiniApp startup phase and balance the loss of the first page performance when openning first time.</p>
                            </dd>
                                <dt>Multiple Rendering Views</dt>
                            <dd><p>The MiniApp uses native page stack management between render views, and the page switching is driving by native code. Therefore, the gesture operation in the page, the switching between pages can achieve the exactly same smooth experience as Native.</p>
                                <p>Becase of the isolation of View layer and Logic layer, the View layer can be rendered independently. Without being blocked by JavaScript logic code, the rendering speed of the page can be greatly improved.</p>
                            </dd>
                                <dt>Pre-built and reuse of runtime environments</dt>
                            <dd>
                                <p>MiniApp's runtime environment is usually pre-built before launching a mini-app, thus reducing the time to launch a MiniApp. Pre-built content includes rendering views, static resources, developer defined prefetch requests, and MiniApps runtime container. After a MiniApp is activated, it will take over the pre-built rendering view, then we continue to pre-built a new render view into the cache pool for the next one. There is a limit on render view quantity, when any render view gets closed or the quantity limit is  exceeded, the oldest opened render view will be destroyed. When the MiniApp application exit, the runtime will be destroyed and the application environment and resources can be reused.</p>
                            </dd>
                                <dt>Pre-defined Component and API</dt>
                            <dd>
                                <p>MiniApp platforms provides very rich <a href="#api_and_component">components and APIs</a>, these components and APIs are usually well designed and able to help ensure the performance of the general work from developers.</p>
                            </dd>
                                <dt>JavaScript framework presets and hot reload</dt>
                            <dd>
                                <p>MiniApp's runtime environment contains two major parts, the basic capabilities provided by Native code, and a framework, include developer API and some components, implemented by JavaScript. The JavaScript framework is built in native Apps, and will be loaded into the MiniApp runtime environment in advance before executing MiniApp. The JavaScript framework can be hot reloaded (reload during usage), which brings lots of possibilities to improve performance.</p>
                            </dd>
                        </dl>
                    </section>
                </section>
                <section>
                    <h2>MiniApp Market</h2>
                    <p>This section describes a few current mainstream MiniApp or relevant platforms.</p>
                    <dl>
                        <dt>Alipay Mini Program</dt>
                        <dd>
                            <p>Alipay Mini Program runs on top of Alipay Native App, which is a hybrid solution of Web and Native. Alipay Mini Program relies on Web technologies as CSS and JavaScript. Meanwhile, it integrates the functionalities of Alipay Native App as payment, credit service, face authentication, etc.</p>
                            <p>Now there have been more than 1,000,000 Mini Programs running on Alipay Native App and 230 million DAU (Daily Active User). The user scenarios include retails, transportation, medical services, etc.</p>
                        </dd>
                        <dt>Baidu Smart Mini Program</dt>
                        <dd>
                            <p>Baidu Smart Mini Program refers to an open ecological product that intelligently connects people to information and services, which based on Baidu APP and other partners’ platforms. Through Baidu’s AI abilities, and by understanding all contents in Smart Mini Programs, we connect user and Smart Mini Program accurately. With Baidu’s search and information flow dual engine,  users can achieve an APP-like experience within Smart Mini Programs. As of July 2019, we have 150,000+ Smart Mini Programs and 270 million MAU.</p>
                            <p>Baidu Smart Mini Program is open-sourced within our open source alliance, which has more than 30 cooperators, covered super APPs, mobile OS, car OS, voice-control speakers and TV.</p>
                        </dd>
                        <dt>Quick Apps (Quick App Alliance including Xiaomi and Huawei)</dt>
                        <dd>
                            <p>Quick App is a MiniApp standard developed by 12 top mobile phone manufacturers in the Quick App Alliance, covering over 200 million MAU. Developers can achieve one-time development and run on all hardware vendors' platforms. Quick Apps, which are deeply integrated in the operating system, can be obtained  in multiple scenarios of the mobile phone system, with just one click. By introducing a native rendering path, an effective combination of front-end development and native performance experience is achieved.</p>
                            <p>Quick Apps can run in two forms: Quick App page form like native app page and a widget form that presents information in the scene. The two are adapted to different user needs, connecting the system and the MiniApp into a whole in multiple forms.</p>
                        </dd>
                        <dt>360 PC MiniApp</dt>
                        <dd>
                            <p>MiniApps on PC is still in an early exploration stage. 360 PC MiniApp is a light application running in their PC browser. Compared to the traditional webpages, it's served with more functionalities and easier interaction with the PC operation system.</p>
                            <p>PC miniapps are only available to those validated as an enterprise account, most of the features are under tough regulations, so that they can be considered as highly trusted web contents.</p>
                        </dd>
                        <dt>PWAs</dt>
                        <dd>
                            <p>PWAs are the latest term to summarize modern web applications. As a counterpart of native apps, a PWAs app looks and feels like a native app, and can be installed to home screen / launcher / start menu; it can send push notification to re-engage user; it can be used when offline and behaves under poor network condition; it works with devices of wide ranging capabilities and it's still evolving to works with new capabilities defined by open web standards; payment can be made by user inside PWAs apps; and PWAs apps are search-engine-friendly and work perfectly with hyper-links. PWAs are successful on both the technical aspect and business aspect (widely adopted by many web sites, esp. consumer facing ones).</p>
                        </dd>
                    </dl>
                </section> 
        </section>
        <section>
            <h2>Working with the Web</h2>
            <p>This section selects some typical use cases and proposes a few APIs that MiniApps would like to have support from the Web.</p>
            <section>
                <h2>Application Lifecycle</h2>
            <section>
                <h2>Hybrid Rendering</h2>
                <p>MiniApp is a hybrid solution of Web rendering and Native rendering. It'd be great if there is a good way to combine the rendering results from the Web and from the Native.</p>
                <figure>
                    <img alt="Rendering results coming from both the Web and the Native" src="images/rendering.png" width="600">
                    <figcaption>
                        Rendering results coming from both the Web and the Native
                    </figcaption>
                </figure>
                <p>Proposal: Mini App needs a standardized API to help integrate the native rendering result into Web rendering result.</p>
            </section>
            <section>
            <h2>Transition Animation</h2>
                <p>MiniApp would like to provide transition animation during page switching so that users can have similar experience as when they are using a Native App, but it's almost impossible to do that now.</p>
                <p>Proposal: Mini App needs an API to call add transition animation during MiniApp page switching.</p>
            </section>
            <section>
            <h2>Standardise the Package Constructor of MiniApp</h2>
                <p>MiniApp can form a package and parsing convention for multiple MiniApp hosting platforms through a standardized distribution format. Currently, each MiniApp hosting platform provides different development tools (different packaging methods), and the MiniApp is parsed differently in different MiniApp hosting environments.</p>
                <p>Proposal: The MiniApp is actually a packaged (compressed) collection of files during the distribution process. We can describe a MiniApp (.ma) with a uniform file suffix and specify how to create the .ma file and how to parse the .ma file.</p>
            </section>
            <section>
            <h2>Standardise the navigation to a MiniApp page</h2>
                <p>For a hot page in a MiniApp, it may be referenced in another MiniApp, and it is expected to be accurately evoked when the user visits.</p>
                <p>Proposal: Define a standardized protocol (URI scheme) to access MiniApp.</p>
            </section>
            <section>
            <h2>MiniApp Widgets</h2>
                <p>Like Android widgets or apple dashboard, users can directly get information and/or finish their task by a MiniApp widget without opening any web or app pages. A MiniApp widget can be displayed in an environment outside of web browsers, such as desktop or dashboard.</p>
                <p>Proposal:</p>
                    <ul>
                        <li>A MiniApp widget can be displayed within a host environment, which could be either webview or a native app page. The host environment loads a widget with its corresponding URI path, which describes a package and widget page.</li>
                        <li>A MiniApp widget can access local data or data from server.  Meanwhile, a MiniApp widget can communicate with MiniApp in the same package.</li>
                        <li>A MiniApp widget should be interactive, meaning that it should be responsive to any user behaviors/interactions. A MiniApp widget should have the ability to open a web or app page.</li>
                    </ul>
            </section>
            </section>

            <section>
                <h2>Performance and Tuning</h2>
            <section>
                <h2>Define an event of time to interactive in MiniApp</h2>
                <p>MiniApp needs to know when the MiniApp page Time to Interactive (TTI) has been completed.</p>
                <p>Proposal: A standardized event to notify that the MiniApp page Time to Interactive has been completed.</p>
            </section>
        </section>

        <section>
                <h2>Graphics and Media</h2>
            <section>
                <h2>3D Model Element</h2>
                <p>3D models become more and more popular thanks to its rich details, and combined with AR, it will provide a much better user experience than 2D.  The business cases might include online shopping, advertisement, education, etc. However, the current web lacks a standard and convenient way to deal with 3D model.  In this document, we propose to define a HTML tag to directly handle 3D model, similar to the way we handle audio, video, image with corresponding HTML tags:</p>
                    <ul>
                        <li>360 view
                            <p>User can view a 3D model from different angles via gestures. And the 3D model can be zoom in/out as well. It can be viewed in full screen, or it can be embedded in a HTML page, shown together w/ other HTML contents.</p>
                        </li>
                        <li>View with AR
                            <p>User can place the 3D model in the real world environment with camera.  User can specify different locations to place the model.</p>
                        </li>
                    </ul>
                <p>Proposal: A <code>&lt;xmodel></code> Element to specify a 3D model on the web and to power interactive 3D contents with AR.</p>
            </section>

            <section>
                <h2>Face Tracking</h2>
                <p>Face tracking can be used in many 3D scenarios.</p>
                <dl>
                        <dt>Face Effects in Live Video</dt>
                        <dd>
                            Add effects on the face in live video. These effects include full-screen filter, face reshape and makeup, 2d sticker, 3d headdress, etc. Most of these effects depend heavily on the real-time face tracking from video source.
                        </dd>
                        <dt>Gaming</dt>
                        <dd>
                            Game developers can design game strategies based on the tracked face. Like triggering a specific game logic when the eye is blinked, or check if the dropping fruit is in the opened mouth.
                          </dd>
                        <dt>Virtual Makeup</dt>
                        <dd>
                          Let users try lipsticks, eye shadows, glasses, hats on the product page to help them make the decision.
                        </dd>
                </dl><p>Proposal: A Face Tracking API use a video element as input and updates face tracking output every frame, which includes:
                    <ul>
                        <li>Bounding box of each face
                        </li>
                        <li>4x4 pose matrix of each face
                        </li>
                        <li>Normalized (x, y) landmarks points
                        </li>
                        <li>ace geometry data including vertices, normals, texture coordinates
                        </li>
                    </ul>
            </section>

            <section>
                <h2>Hand gestures tracking and recognition</h2>
                <p>Hand gestures can be used in video effect and AR/VR games scenario which can make apps more impressive and interactive.</p>
                <p>Proposal: A high-level API to track hands movement, get hands outline.</p>
            </section>

            <section>
              <h2>Low level AR APIs based on ARCore and ARKit</h2>
              <p>There are a few AR APIs in MiniApps we would migrate to the Web, as they help to provide better AR experience in gaming, 3d model preview, interactive ads.</p>
              <p>Proposal: Provide low-level AR APIs based on ARCore and ARKit, which includes:</p>
              <dl>
              <dt>Camera view matrix for world tracking</dt>
              <dd>Provide the 4x4 view matrix of the spatial location and orientation of the mobile phone, which can be used to update the camera matrix in their 3D virtual world in real time by developers. Thereby the position of the real world can be correlated with the position of the object in the virtual world.</dd>
              <dt>Plane detection and tracking</dt>
              <dd>Detect planes in the real world and track these planes in real-time. Provide the 4x4 transform matrix which represents the center position and orientation of each plane. It can be used for placing 3D virtual object on the ground/desktop.</dd>
              <dt>Anchor</dt>
              <dd>Anchor defines a fixed position and orientation in the real world. Developers can create an anchor from a 4x4 transform matrix, which can be got by hit test. This matrix will be updated each frame to ensure that the virtual object corresponding to the matrix can be fixed in one position and direction in the real scene.</dd>
              <dt>Hit test</dt>
              <dd>Get a 4x4 transform matrix representing a position and orientation in the real world space corresponding to the screen position to implement functions such as clicking and placing virtual objects.</dd>
              </dl>
                <figure>
                    <img alt="Better support for AR" src="images/ar_support.png" width="600">
                    <figcaption>
                        APIs to better support AR
                    </figcaption>
                </figure>
            </section>
        </section>
        </section>

        <section>
                <h2>Security and Privacy Consideration</h2>
                <p>MiniApp utilizes HTTPs to support secure connection. Multiple MiniApps within same host environment are independent with each other.</p>
                <p>User interactions within MiniApp needs different level of user permissions:
                </p>
                <table>
                      <tbody><tr>
                        <th>Permission</th>
                        <th>User Interactions</th>
                      </tr>
                      <tr>
                        <td>default(no extra action needed)</td>
                        <td>Page sharing, clipboard, vibration, compass, motion sensors, map, screen brightness, screen capture, battery status</td> 
                      </tr><tr>
                        <td>permission on first-time usage</td>
                        <td>Geolocation, camera(qr code), network status, Bluetooth, NFC</td> 
                      </tr><tr>
                        <td>permission on every usage</td>
                        <td>Contacts, file-apis, add to home screen, photo picker, phone call</td> 
                      </tr><tr>
                        <td>Validate with token</td>
                        <td>Push</td> 
                      </tr><tr>
                        <td>Callback/messaging</td>
                        <td>Password-free Payment</td> 
                      </tr><tr>
                        <td>request password</td>
                        <td>Payment</td> 
                      </tr>
                    </tbody></table>
            </section>

            <section>
                <h2>Way Forward in W3C</h2>
                <p>To meet the use cases and requirements of MiniApps, make the Web standards better support the MiniApp, and explore innovation of user agent and  enrich the Web, we hope to set up a group and include the following work in W3C:</p><ul>
                        <li>coordinate the MiniApp related standardization in W3C as well as to collaborate with other related W3C groups.
                        </li>
                        <li>horizontal review (security, privacy, i18n and a11y).
                        </li>
                    </ul>

                    <p>In details, the following technical work shall be studied further:</p><ul>
                        <li>draft a roadmap for MiniApp standards based on the use cases and requirements selected by the group.
                        </li>
                        <li>develop specifications for  features among current vendors. Target features include but not limited to:
                            <ul>
                        <li>package constructor</li>
                        <li>MiniApp URI scheme</li>
                        <li>hybrid rendering API</li>
                        <li>3D model tag</li>
                        <li>face tracking API </li>
                        <li>Widget</li>
                    </ul>
                        </li>
                        <li>design future Web APIs to be useful for both web and MiniApp environments.</li>
                    </ul>
                 <p>Note: the further gap between current MiniApp APIs and Web APIs will be analyzed in parallel.</p>
            </section>

            <section>
                <h2>Glossary</h2>
                <table>
                      <tbody><tr>
                        <th>Chinese</th>
                        <th>English</th>
                        <th></th>
                      </tr>
                      <tr>
                        <td>小程序</td>
                        <td>Mini Program</td> 
                        <td>One format of MiniApp running within Native Apps.</td> 
                      </tr><tr>
                        <td>快应用</td>
                        <td>Quick App</td>
                        <td>A MiniApp standard developed by 12 mobile phone manufacturers in Quick App alliances.</td> 
                      </tr><tr>
                        <td>渲染环境</td>
                        <td>rendering view</td>
                        <td>Native view or WebView.</td>
                      </tr>
                      <tr>
                        <td>负一屏</td>
                        <td>smart assistant</td> 
                        <td>A smart assistant to provide service for convenience, usually at left of the home screen</td> 
                      </tr><tr>
                        <td>热更新</td>
                        <td>hot reload</td>
                        <td>no need to be re-installed when fixing or updating feature. In MiniApp, because of pratial of framework is realized by JavaScript, so MiniApp runtime can be hot reloaded.</td>
                      </tr>
                    </tbody></table>
            </section>

    <section class="appendix">
      <h2>
        Gap Analysis
      </h2>
      <p>
        Please look at <a href="comparison.html">the comparison table of APIs in MiniApps, W3C specs, and PWAs.</a>.
      </p>
    </section>

            <section class="appendix">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Many thanks to Guanyu Liu (360), He Du (Xiaomi), Hongguang Dong (Xiaomi), Xiaoqian Wu (W3C), Yi Shen (Baidu), Yefeng Xia (China Mobile) who also contributed to this document.
      </p>
    </section>
</body>

</html>
