# MiniApp Package explainer

> Note: This document serves as a supplementary explanation of the [MiniApp Packaging](https://w3c.github.io/miniapp/specs/packaging/) spec. If there is any inconsistency with the spec, you should consider the spec to be authoritative.

## Authors

Yongjing Zhang (Huawei)

## 1. Introduction

### What is this?

A MiniApp Package is a [ZIP](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT)-based container file that wraps a set of files (JS code, components, resources, configurations, styles) comprising the whole MiniApp. 
It can be delivered to a hosting platform through different channels (e.g. web, app store, offline), then rendered/executed by the hosting platform.

### Why should we care?

A MiniApp Package contains all necessary information used by a hosting platform to check, load and execute the MiniApp properly. A standardized format is necessary so that a MiniApp package generated by different developers or tools can be deployed on different hosting platforms (e.g. super-apps, or native-os frameworks) in a compatible and consistent way. The spec shall define the following aspects to ensure interoperability:
* minimum set of files for a MiniApp to be runnable
* optional files for enhanced features
* a well-defined file and directory structure
* pre-defined file names and naming convention
* parsing and validity check mechanism
* the overall file format (and extension name) of the package
* the corresponding MIME type for internet exchange

## 2. MiniApp Package Design
### The Package File Format
Following the common practice of mobile app packaging (such as Android APK), MiniApp package is designed as a specialized ZIP file, which has its own file extension name (`.ma` - tbd) and a dedicated MIME type (`application/miniapp-pkg+zip` - to be registered with IANA).

It can be viewed as normal `.zip` file in some cases (a ZIP parser may open and read the MiniApp package without knowing the MiniApp Packaging spec). However, having the dedicated file extension name and MINE Type gives a way for a hosting platform or a package loader to do pre-checking or content-type negotiation before actually loading/downloading the package.

### The Package Content
To comprise a executable MiniApp, a MiniApp package needs to support the following content (in the form of internal directories and files):
* **manifest.json**: A JSON-based file responsible for the global configuration of the MiniApp. (See [MiniApp Manifest](https://w3c.github.io/miniapp/specs/manifest/)) 
* **app.js**: The main application logic and responsible to the life-cycle management (see [MiniApp Lifecycle](https://w3c.github.io/miniapp/specs/lifecycle/))
* **app.css**: The global/default application style.
* **pages**: A directory contains all page-related resources, and may have sub-directories to group different pages. Each page may have the following associated files:
  * ***.js**:  The page scripts (app logic of the page)
  * ***.xml**: The page layout (whether it's in XML format is under discussion)
  * ***.json**: The page-specific configuration (under discussion)
  * ***.css**: The page-specific style
* **common**: A directory contains common resources (images, scripts, UI components, templates) that can be (re)used by one or multiple pages/widgets. It may have sub-directories to group resources. (Details are for further study.)

> Note: As the MiniApp Packaging spec is still under development, the content listed above is not complete yet and subject to further change.

### Security Considerations
To ensure the integrity and trustworthiness, a MiniApp package SHOULD be protected by one or more digital signatures by the author (e.g. the MiniApp developer) and the distributors (e.g. an application store) along with certificates issued by trusted authorities. (see more in the [spec](https://w3c.github.io/miniapp/specs/packaging/#security-privacy-considerations))

Proven technologies such as [RFC5652](https://tools.ietf.org/html/rfc5652) (i.e. PKCS#7) can be leveraged, and the binary package archive format needs enhancement by insert the "signing block" (similar to [APK Signature Scheme v2](https://source.android.com/security/apksigning/v2)) in the basic ZIP file.

The detailed solution is under development. 


## 3. Sample

One typical illustrative example of a MiniApp package is given in the [spec](https://w3c.github.io/miniapp/specs/packaging/#example-1).

## 4. Comparison with Other Packaging Technologies

There are already some other packaging technologies specified for different purposes, such as [Widgets (obsolete)](https://www.w3.org/TR/widgets), [WICG WebPackage (WPACK)](https://github.com/WICG/webpackage) and its [obsolete version](https://www.w3.org/TR/2015/WD-web-packaging-20150115/), and [Lightweight Packaging Format (LPF)](https://www.w3.org/TR/lpf/). They are designed based on different archive formats (e.g. ZIP, CBOR), use different signature mechanisms (e.g. [XMLDSIG](http://www.w3.org/TR/xmldsig-core1/)-based, HTTP-based) and contain different types of contents (e.g. web pages, http exchanges, digital publications). Such differences result from the diversity of the environment assumptions and the technical requirements of individual technologies.

The MiniApp package also has its unique assumptions and requirements that cannot be addressed directly by existing technologies. It's essentially a mobile application package designed to pack all required application materials (e.g. pages, layouts, UI components, resources, scripts and configurations) to be deployed and executed by various application hosting platforms (such as "Mini Program" [[1]](https://smartprogram.baidu.com/developer/index.html)[[2]](https://open.alipay.com/channel/miniIndex.htm)[[3]](https://mp.weixin.qq.com/cgi-bin/wx) and [Quick App](https://www.quickapp.cn/)), rather than to pack web contents or digital publications to be loaded by browsers or e-book readers. The following analysis summarizes the main reasons why **existing packaging technologies cannot meet the needs of MiniApp packaging**:

1. **[WPACK](https://github.com/WICG/webpackage):** It's intended to pack a collection of web resources in terms of HTTP exchanges (including HTTP requests, responses, signatures and other metadata), so that a browser can load them locally and recover the web transaction states securely without accessing the origin. To achieve this, a HTTP-specific signature mechanism is defined which is apparently not suitable for MiniApp that doesn't rely on HTTP exchanges. Moreover, WPACK proposes to define a new CBOR-based archive format instead of using ZIP for web-specific [reasons](https://github.com/WICG/webpackage/issues/45) that don't apply to MiniApp. For instance, ZIP resources are file-based so that are not efficient for HTTP response headers in WPACK, but can serve MiniApp very well and are already used widely in mobile application packaging implementations (e.g. Android APK, QuickApp, MiniProgram). 
2. **[Web Package (obsolete)](https://www.w3.org/TR/2015/WD-web-packaging-20150115/):** It's an unfinished work as the ancestor of WPACK. It choses not to use ZIP but define a new Streamable Package Format for its specific reasons that are not seen by MiniApp. Again it's designed as closely coupled with HTTP (headers) which is not suitable for MiniApp.
3. **[Widgets (obsolete)](https://www.w3.org/TR/widgets):** It's an old implementation of Packaged Web Apps called Widgets. It's ZIP-based but has its specific constraints on file/folder structure and naming, and it uses XML-based configuration document. These constraints are not compatible with MiniApp. In addition, it uses [XMLDSIG](http://www.w3.org/TR/xmldsig-core1/) for the digital signature, which can only protect the files that are signed but not the entire package file itself. One can add/remove signature files, add other files or blocks into the ZIP package, or alter the ZIP metadata without being noticed. Such vulnerability is not acceptable by MiniApp.
4. **[LPF](https://www.w3.org/TR/lpf/):** It's a lightweight ZIP-based packaging format which contains digital publication materials. It mandates publication-specific files (i.e. `publication.json`, `index.html`) that are not needed by a MiniApp, while misses files required for a MiniApp (e.g. `manifest.json`, `app.js`). And it has not cover the security concerns (e.g. integrity protection of the whole package) that a MiniApp should address.

A detailed comparison between MiniApp package and other packaging technologies is give in the following table:


Technology | Client Platform | Content | Web Dependency | Format | Digital Signature 
:---    |:---    |:--        |:---   |:---    |:--   
MiniApp | Super-App, OS, or Browser* | Application-resources (e.g. app logics, page layouts, UI components – not necessarily h5-based) | No (may or may not use web resources) | ZIP-based | PKCS#7* 
WPACK | Browser | Web content (HTTP exchanges) | Yes (a web origin is always assumed, even offline) | CBOR-based | HTTP header extension 
WebPackage (old) | Browser | Web content | Yes (a web origin is always assumed, even offline) | Streamable Package Format (.pack) | n/a 
Widgets | Browser, OS | Widget files (html start files, XML configuration, icons ...) | No (may or may not use web resources) | ZIP-based | XMLDSIG-based 
LPF | e-Readers |  Digital publications, configuration | No | ZIP-based | unknown* 

>Note: `*` in the table above denotes the feature that is under discussion/development.

To summarize, although MiniApp leverages popular web front-end technologies like JS, CSS, it’s more like a native-app rather than a snapshot of a web-content collection. Existing web packaging technologies cannot cover the requirements of MiniApp, therefore a dedicated MiniApp Packaging specification needs to be developed.




