<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>MiniApp Standardization White Paper version 2</title>

    <style>
    .two-cols {
      display: grid;
      grid-template-columns: 1fr 1fr;
    }

    table {
      border-collapse: collapse;
    }

    table, th, td {
      border: 1px solid #666;
    }

    th, td {
      padding:2px 15px;
    }
    </style>

    <script async class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>

    <script class="remove">
        var respecConfig = {
            specStatus: "ED",
            previousPublishDate: "2019-09-12",
            previousMaturity: "WD",
            copyrightStart: "2019",
            edDraftURI: "https://w3c.github.io/miniapp/white-paper/",

            shortName: "mini-app-white-paper",
            noRecTrack: true,
            copyrightStart: "2019",

            editors: [{
                name: "Qing An",
                companyURL: "https://www.alibabagroup.com/en/global/home",
                company: "Alibaba",
                w3cid: 76701
              }, {
                name: "Dan Zhou",
                companyURL: "https://www.baidu.com/",
                company: "Baidu, Inc",
                w3cid: 118521
              }, {
                name: "Martin Alvarez-Espinar",
                companyURL: "https://www.huawei.com/",
                company: "Huawei",
                w3cid: 125049,
              }, {
                name: "Zitao Wang",
                companyURL: "https://www.huawei.com/",
                company: "Huawei",
                w3cid: 124483
              }, {
                name: "Wanming Lin",
                companyURL: "https://www.intel.com/",
                company: "Intel Corporation",
                w3cid: 91067
              }, {
                name: "Kaining Yuan",
                companyURL: "https://www.intel.com/",
                company: "Intel Corporation",
                w3cid: 118212
              }, {
                name: "Canfeng Chen",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi",
                w3cid: 124040
              }, {
                name: "Yinli Chen",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi",
                w3cid: 117298
              }, {
                name: "Anqi Li",
                companyURL: "https://www.w3.org/",
                company: "W3C",
                w3cid: 40190
              }, {
                name: "Fuqiao Xue",
                companyURL: "https://www.w3.org/",
                company: "W3C",
                w3cid: 95475
              }],

              formerEditors: [{
                name: "Dapeng Liu",
                companyURL: "https://www.alibabagroup.com/en/global/home",
                company: "Alibaba",
                w3cid: 76699
              }, {
                name: "Hongru Zhu",
                companyURL: "https://www.alibabagroup.com/en/global/home",
                company: "Alibaba",
                w3cid: 76462
              }, {
                name: "Qingqian Tao",
                companyURL: "https://www.baidu.com/",
                company: "Baidu, Inc",
                w3cid: 101978
              }, {
                name: "Zhixing Lei",
                companyURL: "https://www.baidu.com/",
                company: "Baidu, Inc",
                w3cid: 53404
              }, {
                name: "Lei Zhao",
                companyURL: "https://www.10086.cn/",
                company: "China Mobile",
                w3cid: 110287
              }, {
                name: "Zhiqiang Yu",
                companyURL: "https://www.huawei.com/",
                company: "Huawei",
                w3cid: 102877
              }, {
                name: "Xiaowei Jiang",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi",
                w3cid: 115244
              }],

            group: "wg/miniapps",
            wgPublicList: "public-miniapps-wg",

            github: "w3c/miniapp"
        };
    </script>
</head>

<body>
    <section id='abstract'>
        <p>
        This document introduces a new format for mobile applications, named MiniApp, which is a very popular hybrid solution relying on Web technologies but also integrates with capabilities of the native apps.
        </p>
    </section>
    <section id='sotd'>
    </section>

    <section>
        <h2>Introduction</h2>
        <section>
            <h2>Problems</h2>
            <p>Native apps are well received in our daily life, but there are still many things that can be done better for users.</p>
            <ul>
                <li>
                    <p>Before users get the service from a native app, they often have to go through the process of downloading -> installing -> registering the app.</p>
                    <p>Users can only keep a limited number of native apps on their phones due to the constraints of storage capability.</p>
                    <p>It's not easy to share data between different native apps.</p>
                </li>
                <li>
                    <p>To work on a native app, developers may need to learn a few new programming languages.</p>
                    <p>To provide the same service as native apps, developers may need to maintain duplicate products for different platforms.</p>
                </li>
            </ul>
            <p>The Web is an ideal platform to avoid these problems, but it's still imperfect by far.</p>
            <ul>
                <li>
                    <p>Compared to the native, it isn't easy to take advantage of the capabilities provided by the system. </p>
                    <p>Also, it's usually difficult to design a Web application whose performance can actually match or surpass a similar native app.</p>
                </li>
                <li>
                    <p>On a mobile device, users frequently obtain services or contents outside the browser; naturally, they would like all their applications to be consistent on user accounts, login status, and user interaction across the whole system.</p>
                    <p>Moreover, sometimes users may want to share some data with an application if they really trust it. Still, for a few frequently requested information, such as the personal mobile number of the current device, or the contact list, there isn't a good way for the users to give permits on the Web.</p>
                </li>
            </ul>
        </section>
        <section>
            <h2>What is MiniApp?</h2>
                <p>MiniApp is a new mobile application format, a hybrid solution that relies on Web technologies (especially CSS and JavaScript) and integrates with the capabilities of native apps.</p>
                <p>A <dfn>super app</dfn> is a software platform that hosts and supports other applications (i.e., MiniApps), enabling their execution by using the platform's resources.</p>
                <p>MiniApps got popular from their usage on a few <a>super apps</a>, as it was born with a few characters that helped fill the gap between the Web and the native.</p>
                <ul>
                    <li>It's free of installation.</li>
                    <li>Multiple WebViews to improve performance.</li>
                    <li>It provides a few mechanisms to access OS capabilities or data through the native.</li>
                    <li>The content is usually more trustworthy because the app needs to be validated by the platform.</li>
                    <li>A MiniApp can be distributed to multiple MiniApp platforms (the Web, a native app, even the OS). These platforms also provide entry to the MiniApp to ensure the users can easily discover it.</li>
                </ul>
            </section>
            <section>
                <h2>Gap between MiniApps and PWA</h2>
                <p>MiniApps are <em>not</em> aimed to replace PWA, the Web, or the native apps.</p>
<p>MiniApps and PWAs are composed of the same resources (i.e., scripts, markup-language-based documents, stylesheets, multimedia, etc.). The type of documents and their coding languages are similar, but MiniApps implement specific dialects and built-in services that are not standard. </p>
<p>Apart from the format, MiniApp's resources are usually packed in a self-contained physical structure that enables a flexible distribution from app marketplaces to offline exchange. </p>
<p>The main difference between PWAs and MiniApps is the execution environment. MiniApp user agents are <a>super apps</a> or platforms implemented on the operating system, while PWA user agents are usually web browsers.  </p>
<p>Although both technologies have similar APIs and services, there is a significant gap between the API specifications in each application type. PWAs rely on standard Web APIs, while MiniApps implement non-standard APIs to maximize the platform's capabilities, such as device-specific features and vendor-exclusive services.  </p>
<p>MiniApp vendors define similar UI (User Interface) elements that do not always have a direct equivalent in HTML. </p>
<p>Depending on the implementation, a MiniApp user agent could be an operating system, a <a>super app</a>, or any other hosting platform based on different and various rendering engines and WebViews. The architecture of a MiniApp user agent differs from PWA user agents, as we can see in the following picture.</p>

<figure>
  <img alt="The architecture of MiniApps and PWA" src="images/miniapp_pwa.svg" width="800">
  <figcaption>
    The architecture of MiniApps and PWA
  </figcaption>
</figure>

<p>
  The main differences between them can be summarized in the following table.
</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Progressive Web App</th>
      <th>MiniApp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Source code</td>
      <td>Standard markup languages (HTML), stylesheets (CSS), and scripts (JavaScript). </td>
      <td>Non-standard dialects of HTML, CSS and JavaScript</td>
    </tr>
    <tr>
      <td>Deployed Format</td>
      <td>Web resources (mainly: HTML, CSS, JavaScript code, and WebAssembly modules)</td>
      <td>HTML, CSS, JavaScript, and other resources packed in a container. </td>
    </tr>
    <tr>
      <td>Packaging</td>
      <td>No. Resources linked on the Web.</td>
      <td>Yes. Different package formats per vendor.</td>
    </tr>
    <tr>
      <td>Needs to host files on web server</td>
      <td>Yes </td>
      <td>No</td>
    </tr>
    <tr>
      <td>Installation-free usage</td>
      <td>Yes, running in the browser.</td>
      <td>Running in a <a>super app</a> or on the OS.</td>
    </tr>
    <tr>
      <td>Installation with standalone icon</td>
      <td>From the browser or app store (optional)</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Services </td>
      <td>Access to Web APIs</td>
      <td>Access to non-standard Web APIs, including some system native APIs</td>
    </tr>
  </tbody>
  </table>

            </section>
            <section>
                <h2>Case studies</h2>
                <section>
                    <h2>Case 1: Shared Bicycle Service</h2>
                    <p>The popularization of MiniApps helps make the shared bike a seamless service instead of a cumbersome application.</p>
                    <div class="two-cols">
                    <ul>
                        <li>A user chooses any of the MiniApp platforms on their mobile device, which is usually a <a>super app</a> that they already logged in to;</li>
                        <li>A user scans the QR-code label attached to a shared bicycle within the <a>super app</a>;</li>
                        <li>The hosted app will automatically navigate to the shared bicycle MiniApp and unlocks the bicycle instantly;</li>
                        <li>Upon arrival, user locks the bike on the MiniApp;</li>
                        <li>Transaction completes, a message of the payment detail is sent to the user.</li>
                    </ul>
                    <figure>
                      <img alt="Shared Bicycle Service" src="images/shared_bike.png" width="200">
                      <figcaption>
                        Shared Bicycle Service with MiniApp
                      </figcaption>
                    </figure>
                    </div>
                    <p>For users, MiniApps can bring convenient from a few perspectives:</p>
                    <table>
                      <tbody><tr>
                        <th></th>
                        <th>the Web</th> 
                        <th>Native app</th>
                        <th>MiniApp</th> 
                      </tr>
                      <tr>
                        <td>Download/Install</td>
                        <td>No</td> 
                        <td>Yes</td>
                        <td>No</td> 
                      </tr>
                      <tr>
                        <td>Verified/Trusted</td>
                        <td>No</td> 
                        <td>Yes</td>
                        <td>Yes</td>
                      </tr>
                      <tr>
                        <td>Login/Register</td>
                        <td>Yes</td> 
                        <td>Yes</td>
                        <td>User permission</td>
                      </tr>
                      <tr>
                        <td>Payment</td>
                        <td>Send a payment request</td> 
                        <td>Register a credit card or navigate to another app</td>
                        <td>Complete within the hosted app</td>
                      </tr>
                    </tbody></table>

                </section>

                <section>
                    <h2>Case 2: AR Zoo</h2>
                    <p>MiniApp developers can simply use HTML/CSS/JavaScript as the programming language, but MiniApp is more flexible so it excels at quick development of complex features in daily work.</p>
                    <p>This MiniApp tries to build an AR zoo with AI technologies to recognise the animals. Developers can easily do that by adding a few components or APIs that provide access to the native capabilities or advance features (e.g., Image Recognition, AR 3D Animal models rendering, a speech API to for speech synthesis, and AR navigation provided by the map SDK).</p>
                    <p>MiniApps can be discovered by the search engines, by the MiniApp store in the hosted app or by QR-code.
                    <figure>
                      <img alt="AR zoo" src="images/ar_zoo.png" width="600">
                      <figcaption>
                        AR Zoo MiniApp
                      </figcaption>
                    </figure>
                    <p>For the developers, the incentive to work on MiniApps is very obvious.</p>
                    <table>
                      <tbody><tr>
                        <th></th>
                        <th>the Web</th> 
                        <th>Native app</th>
                        <th>MiniApp</th> 
                      </tr>
                      <tr>
                        <td>Discoverability</td>
                        <td>Search Engine</td> 
                        <td>App Store</td>
                        <td>Multiple: search engines + MiniApp store in the hosted apps + QR-code</td> 
                      </tr>
                      <tr>
                        <td>Verified/Trusted</td>
                        <td>Still exploring</td> 
                        <td>by native app stores</td>
                        <td>by host app platforms</td>
                      </tr>
                      <tr>
                        <td>Deploy/Reload</td>
                        <td>load/reload the webpage</td> 
                        <td>installed/reinstalled</td>
                        <td>load/reload as it's using a JS engine</td>
                      </tr>
                      <tr>
                        <td>Programming Language</td>
                        <td>Web programming language</td> 
                        <td>new/multi languages: iOS and Android at least</td>
                        <td>Web programming language</td>
                      </tr>
                      <tr>
                        <td>APIs/Components (AR, Image Recognition, Geolocation, Speech API)</td>
                        <td>very basic</td> 
                        <td>complex for web developers</td>
                        <td>very simple high-level APIs and components</td>
                      </tr>
                    </tbody></table>
                </section>

                <section>
                    <h2>Case 3: MiniApp for Vehicle</h2>
                    <p>One of the goals of MiniApp to connect information and services across different platforms, so it's ideal for IoT applications such as Smart Automotive, voice-control speaker and Smart TV.</p>
                    <p>Nowadays, it's possible to convert some MiniApps to adapt the vehicle screen and system, also, a few MiniApp vendors have built a MiniApp platform specially design for the vehicle system, to help distribute or upgrade applications to various of car model. This brings millions of Web developers to the Automotive application ecosystem.</p>
                    <p>These Automotive MiniApps can service many user scenarios, including gas filling, car washing, Electronic Toll Collection, insurance, restaurant reservation, or entertainment. For example, when the system detects the remaining fuel is less than 20%, it can recommend to the owner a Gas Pumping MiniApp. The user can get the information of the nearest gas station and head there to complete the gas pumping including the payment within MiniApp, "refueling without getting off the vehicle".</p>
                    <figure>
                      <img alt="smart car" src="images/smart_cars.png" width="600">
                      <figcaption>
                        MiniApp for Smart Car(Gas Pumping App)
                      </figcaption>
                    </figure>
            </section>

            <section>
              <h2>Case 4: MiniApp for IoT</h2>
              <p>IoT device is becoming another carrier running MiniApps. MiniApp for IoT intends to enable interoperability across multiple IoT device platforms and IoT operating systems. Rather than having to deal with the difference across the multiple IoT device platforms and IoT operating systems, by introducing MiniApps for IoT, developers only need to focus on the application development on IoT devices.</p>

              <p>One example is HVAC (heating, ventilating, and air-conditioning)
                application switch panel which has a screen and several physical buttons. In this case, by introducing MiniApp for IoT, the switch panel’s screen UI can be designed and developed using Web technologies, to display the HVAC information. For example, the target temperature value inputted by the physical and the measured real-time temperature value can be displayed.</p>
              <figure>
                <img alt="IoT MiniApp" src="images/hvac.png" width="300">
                <figcaption>
                  IoT MiniApp running on HVAC application switch panel having a screen and several physical buttons
                </figcaption>
              </figure>

              <p>
                Another example is smart speakers with a touch screen. In this case, by introducing MiniApp for IoT, the smart speaker’s touch screen UI can be designed and developed using Web technologies, to play music and video, to control the IoT devices at home, to do online shopping.
              </p>

              <figure>
                <img alt="IoT MiniApp on smart speaker" src="images/smart_speaker.png" width="300">
                <figcaption>
                  IoT MiniApp running on smart speaker with a touch screen
                </figcaption>
              </figure>
      </section>

      <section>
        <h2>Case 5: MiniApp for TV</h2>
        <p>Unlike MiniApps running on mobile phones where user interaction depends on the touch screen, the user interaction of MiniApps running on TV switches to TV remote panel keyboard plus TV screen focus.
        </p>

        <p>With MiniApp for TV, users can buy merchandise on TV through E-commerce MiniApp.</p>
        <figure>
          <img alt="E-commerce MiniApp running on TV" src="images/tv_e_commerce.png" width="600">
          <figcaption>
            E-commerce MiniApp running on TV
          </figcaption>
        </figure>

        <p>
          And also, users can play games on TV through Gaming MiniApps.
        </p>

        <figure>
          <img alt="Gaming MiniApp running on TV" src="images/game_tv.png" width="600">
          <figcaption>
            Gaming MiniApp running on TV
          </figcaption>
        </figure>
        </section>

            </section>
        </section>
            <section>
                <h2>MiniApp Overview</h2>
                <section>
                    <h2>Core Features</h2>
                    <section id="separate-the-view-layer-from-the-logic-layer">
                        <h2>Separate the View Layer from the Logic Layer</h2>
                        <p>In a MiniApp, the view layer is usually separated from the logic layer.</p>
                        <figure>
                          <img alt="logic layer and view layer" src="images/logic_view.png" width="400">
                          <figcaption>
                            General Architecture of MiniApp
                          </figcaption>
                        </figure>
                        <p>The View Layer is responsible for rendering MiniApp pages, including Web components rendering and native components rendering, which can be considered as hybrid rendering. For example, Web components rendering can be handled by WebView, but some of the Web components rendering aren't supported by WebView or have performance limitation, MiniApp also relies on some native components, such as map, video, etc.</p>
                        <p>Logic Layer is implemented with JS Worker. The Worker is responsible for MiniApp’s event processing, API calling and lifecycle management.</p>
                        <p>Extended native capabilities usually come from the hosting native app or OS, including payment, file processing, scanning, phone call, etc. These capabilities are called through certain APIs. When a Mini App calls a native API, it transfers the API calling to Extended Native Capabilities for further processing via JS Bridge, and obtains the result from Extended Native Capabilities via JS Bridge.</p>
                        <figure>
                          <img alt="data flow of MiniApp when an API is called" src="images/data_flow.png" width="600">
                          <figcaption>
                            Data flow of MiniApp when an API is called
                          </figcaption>
                        </figure>
                        <p>Worker establishes connection for each Render, transferring the need-to-be-rendered data to render for further processing.</p>
                        <p>If an event is triggered by a component in a MiniApp page, this page’s Render will send the event to worker for further processing. At the same time, the Render will wait for the data sent from worker to re-render the MiniApp page.</p>
                        <p>The rendering can be considered as stateless, and all the states will be stored in the worker.</p>
                        <p>The benefits of separating the View Layer and the Logic Layer include:</p>
                        <ul>
                            <li>Very handy for data sharing and interaction among multiple MiniApp pages.</li>
                            <li>Having the same context within a lifecycle of MiniApp can provide a similar coding experience for those developers coming from native app developement background.</li>
                            <li>Separation and parallel implementation of Render and JS worker can prevent the situation where a JS execution impacts or slows down the page rendering, which can help enhance the performance of rendering.</li>
                        </ul>
                    </section>
                    <section id="api_and_component">
                        <h2>Rich APIs and Components</h2>
                        <p>MiniApp platform provides many components to help developers build a fancy UI, including basic components like View, Form, Image, and high-level component like Maps.</p>
                        <p>MiniApp vendors also offer a number of APIs for developers to get access to capabilities of both the Web and the native, including basic APIs such as UI display APIs, Image API, and those advanced ones like Account API, Map API, Payment API.</p>
                        <p>APIs usually work together with components. When user clicks certain component on a MiniApp page, it will call the related API to complete user’s interaction and refresh the current MiniApp page if needed.</p>
                    </section>
                    <section id="constructor">
                        <h2>MiniApp Constructor</h2>
                        <p>In order to obtain similar user experiences to native apps, MiniApp resources are usually packaged together. After downloading and installing a MiniApp package, all static page templates/CSS/JavaScript files need to present app pages already exist on users' machines. These resources are always available without any redundant downloads until next update.</p>
                        <p>A MiniApp package is a compressed ZIP archive, including:</p>
                            <ul>
                                <li>one configuration document, located at the root directory of the package. The config file should include:
                                    <ul>
                                        <li>general description of the entire MiniApp.</li>
                                        <li>description of pages and their corresponding paths, for the purpose of page locating and opening.</li>
                                    </ul></li>
                                    <li>one app-level logic file, containing JavaScript codes, deals with app-level lifecycle callbacks.</li>
                                    <li>one or multi page files, containing templates codes for page structure, CSS codes for page style, and JavaScript codes for page logic.</li>
                                    <li>support digital signature for validation.</li>
                            </ul>
                            <p>For the purpose of locating a specific MiniApp while searching and executing, a MiniApp must have a package name or an ID on the platform. An icon is also required for user recognization.</p>
                    </section>
                    <section>
                        <h2>MiniApp Widgets</h2>
                        <p>In addition to being presented in the form of an MiniApp page, MiniApp can also be displayed in the form of information fragment, that is, a MiniApp widget. In this form, developers can put their service and/or content to various host scenarios, called host environment, such as assistants, search page, etc.. This feature connects services of the MiniApp with the scenario, providing users with more convenience.</p>
                        <p>For example, when a user purchases a train ticket for trip, the MiniApp widget on <a href="#term.smart-assistant">smart assistant</a> shows the train's latest status immediately. The user can click on this widget and jump to a full-screen MiniApp page for more detailed information.</p>
                        <figure>
                          <img alt="Widget from home screen to MiniApp" src="images/widget.png" width="600">
                          <figcaption>
                            Widget from home screen to MiniApp
                          </figcaption>
                        </figure>
                        <p>Same as MiniApp page, widget is also described by URI scheme. The host environment specifies the MiniApp package and the corresponding widget to be loaded through URI path, and passes data to the widget through URI query params. After the widget is loaded, it is displayed and rendered in the host environment. Data from the host and widget, as well as data from different widgets are isolated to ensure security and independence.</p>

                        <p>In many scenarios, a widget can open a MiniApp page for more complicated operations. In such cases, widgets often need to share data with its corresponding MiniApp (e.g., maintain a consistent login status). Therefore, the data of the widget and the MiniApp can be accessed from each side. In other word, MiniApp widget and page have same data access rights.</p>

                        <figure>
                          <img alt="widget interaction" src="images/widget_interaction.png" width="600">
                          <figcaption>
                            MiniApp widget interaction
                          </figcaption>
                        </figure>

                        <p>One of the goals of the widget is to let the user forget the traditional app concept and truly meet the user's needs in the form of service. So in addition to all app invocation paths, widgets can also be triggered by different methods on different scenarios, such as text keywords, voice analysis, picture recognition, scan code, event intent.</p>
                        <p>Note: Widget is implemented by Quick App in China market.</p>
                    </section>
                    <section>
                        <h2>Single-Instance, Multi-Entries</h2>
                        <p>There are multiple entrances to discover, open and access MiniApps. Unlike Web in multi WebView, only one instance will be created for the same MiniApp, so MiniApp keeps its status and data in a consistent manner globally. For example, after one user opens and logs in a MiniApp through the entrance of QR code for the first time, the user will remain logged in next time when the user returns from another entrance like MiniApp store.</p>
                        <p>The entries for MiniApps include, but not limit to:</p>
                        <ul>
                            <li>MiniApp store</li>
                            <li>Search Engine</li>
                            <li>Smart Assistant</li>
                            <li>QR code</li>
                            <li>SMS/text</li>
                            <li>Physical Object(with AI)</li>
                            <li>Browser</li>
                            <li>Calender items</li>
                            <li>Voice message(with AI)</li>
                        </ul>  
                    </section>
                    <section>
                        <h2>Performance and User Experience</h2>
                        <p>MiniApps try to improve their performance and user experience with a few mechanisms that have been proved to be effective through practice.
                        <dl>                            
                                <dt>Packaging</dt>
                                <dd><p>With <a href="#constructor">MiniApp's constructor</a>, user only needs to download the package when the MiniApp is first opened, and then the static resources(pages/JavaScript/CSS) in the MiniApp needn't be downloaded again, so that the loading and jumping of the following pages can be more quickly responded. This feature improves user operation experience and save network traffic.</p>
                                <p>Meanwhile, the MiniApp has a pre-download mechanism, which can download the MiniApp packages in advance, or pre-downloads separately for the first page, and perform streaming decompression in parallel during download to minimize the time-consuming of MiniApp startup phase and balance the loss of the first page performance when openning first time.</p>
                            </dd>
                                <dt>Multiple Rendering Views</dt>
                            <dd><p>The MiniApp uses native page stack management between render views, and the page switching is driving by native code. Therefore, the gesture operation in the page, the switching between pages can achieve the exactly same smooth experience as native.</p>
                                <p>Because of the isolation of View layer and Logic layer, the View layer can be rendered independently. Without being blocked by JavaScript logic code, the rendering speed of the page can be greatly improved.</p>
                            </dd>
                                <dt>Pre-built and reuse of runtime environments</dt>
                            <dd>
                                <p>MiniApp's runtime environment is usually pre-built before launching a mini-app, thus reducing the time to launch a MiniApp. Pre-built content includes rendering views, static resources, developer defined prefetch requests, and MiniApps runtime container. After a MiniApp is activated, it will take over the pre-built rendering view, then we continue to pre-built a new render view into the cache pool for the next one. There is a limit on render view quantity, when any render view gets closed or the quantity limit is  exceeded, the oldest opened render view will be destroyed. When the MiniApp application exit, the runtime will be destroyed and the application environment and resources can be reused.</p>
                            </dd>
                                <dt>Pre-defined Component and API</dt>
                            <dd>
                                <p>MiniApp platforms provides very rich <a href="#api_and_component">components and APIs</a>, these components and APIs are usually well designed and able to help ensure the performance of the general work from developers.</p>
                            </dd>
                                <dt>JavaScript framework presets and hot reload</dt>
                            <dd>
                                <p>MiniApp's runtime environment contains two major parts, the basic capabilities provided by native code, and a framework, include developer API and some components, implemented by JavaScript. The JavaScript framework is built in native Apps, and will be loaded into the MiniApp runtime environment in advance before executing MiniApp. The JavaScript framework can be hot reloaded (reload during usage), which brings lots of possibilities to improve performance.</p>
                            </dd>
                        </dl>
                    </section>

                    <section>
                      <h2>Login</h2>
                      <p>
                        The MiniApp platforms provide a variety of ways for a user to log in to the MiniApp. If the user has already logged in to the platform with identity authentication, the login information of the platform can be shared with MiniApp, quickly realizing the interoperability of MiniApp’s own account system and the platform account system, which makes the access process of the MiniApp more smooth.
                      </p>
                      <p>
                        For example, the traditional login process with SMS verification is more time-consuming, users need to manually enter their cell phone number first, and then enter the verification code after receiving the SMS to log in. The advantage of MiniApp is that developers can use the components / APIs provided by the platform to obtain users' cell phone numbers securely and conveniently, prompting the user to authorize one-click login process with their cell phone numbers, which makes the entire process simple for the user and reduces the cost of obtaining user information for developers.
                      </p>
                      <figure>
                        <img alt="Sign in to a MiniApp" src="images/login.png" width="300">
                        <figcaption>
                          Sign in to a MiniApp
                        </figcaption>
                      </figure>
                  </section>

                  <section>
                    <h2>Subpackaging</h2>
<p>MiniApp subpackaging is a build mechanism for improving the MiniApp package development process. It helps developers divide different business modules into different subpackages.</p>
<p>For developers: a MiniApp has the main package by default, it contains the startup page files and public resources. Subpackage is a building type that flexibly way divided the developer's business modules. Users can open special pages after loading different sub-packages on demand.</p>
<p>For users: when the user starts the MiniApp, the main package will be downloaded by default and the page in the main package will be launched. If the user needs to open a page in the subpackage, the MiniApp Runtime will start to download and load the subpackage and start the subpackage page.</p>
<p>Through such a subpackage building mechanism is better to decouple and collaborate when multiple teams develop together. When users use the MiniApps, the subpackaging mechanism can improve the loading speed of the MiniApp homepage, load subpackages on demand, and optimize the user experience.</p>
                </section>

                <section>
                  <h2>Add-ons
                  </h2>
                  <p>In a MiniApp, an add-on / extension is an encapsulated module that adds a specific feature to an existing MiniApp, and it could be a component, a JavaScript module, or a page. The add-on / extension can be only executed in a MiniApp instead of running separately. Developers can develop add-on / extension just like a MiniApp, and upload it to the MiniApp platform for other MiniApps to reuse.</p>
                  <p>MiniApp supports add-on / extension to:</p>
                  <ul>
                  <li>reduce development costs by code reuse and help developers easily add new features</li>
                  <li>update functionality automatically without awareness of developers</li>
                  <li>reduce the package size of MiniApps by not loading unused functions</li>
                  </ul>
                  <p>The add-on / extension mechanism lowers the barriers of developing MiniApps and brings more developers to the MiniApp ecosystem.</p>
              </section>
                </section>
                <section>
                    <h2>MiniApp Market</h2>
                    <p>This section describes a few current mainstream MiniApp or relevant platforms.</p>
                    <dl>
                        <dt>Alipay Mini Program</dt>
                        <dd>
                            <p>Alipay Mini Program runs on top of Alipay native app, which is a hybrid solution of Web and native. Alipay Mini Program relies on Web technologies as CSS and JavaScript. Meanwhile, it integrates the functionalities of Alipay native app as payment, credit service, face authentication, etc.</p>
                            <p>Now there have been more than 1,000,000 Mini Programs running on Alipay native app and 230 million DAU (Daily Active User). The user scenarios include retails, transportation, medical services, etc.</p>
                        </dd>
                        <dt>Baidu Smart Mini Program</dt>
                        <dd>
                            <p>Baidu Smart Mini Program refers to an open ecological product that intelligently connects people to information and services, which based on Baidu APP and other partners’ platforms. Through Baidu’s AI abilities, and by understanding all contents in Smart Mini Programs, we connect user and Smart Mini Program accurately. With Baidu’s search and information flow dual engine,  users can achieve an APP-like experience within Smart Mini Programs. As of July 2019, we have 150,000+ Smart Mini Programs and 270 million MAU.</p>
                            <p>Baidu Smart Mini Program is open-sourced within our open source alliance, which has more than 30 cooperators, covered <a>super apps</a>, mobile OS, car OS, voice-control speakers and TV.</p>
                        </dd>
                        <dt>Quick Apps (Quick App Alliance including Xiaomi and Huawei)</dt>
                        <dd>
                            <p>Quick App is a MiniApp standard developed by 12 top mobile phone manufacturers in the Quick App Alliance, covering over 200 million MAU. Developers can achieve one-time development and run on all hardware vendors' platforms. Quick Apps, which are deeply integrated in the operating system, can be obtained  in multiple scenarios of the mobile phone system, with just one click. By introducing a native rendering path, an effective combination of front-end development and native performance experience is achieved.</p>
                            <p>Quick Apps can run in two forms: Quick App page form like native app page and a widget form that presents information in the scene. The two are adapted to different user needs, connecting the system and the MiniApp into a whole in multiple forms.</p>
                        </dd>
                        <dt>360 PC MiniApp</dt>
                        <dd>
                            <p>MiniApps on PC is still in an early exploration stage. 360 PC MiniApp is a light application running in their PC browser. Compared to the traditional webpages, it's served with more functionalities and easier interaction with the PC operation system.</p>
                            <p>PC MiniApps are only available to those validated as an enterprise account, most of the features are under tough regulations, so that they can be considered as highly trusted web contents.</p>
                        </dd>
                        <dt>PWAs</dt>
                        <dd>
                            <p>PWAs are the latest term to summarize modern web applications. As a counterpart of native apps, a PWAs app looks and feels like a native app, and can be installed to home screen / launcher / start menu; it can send push notification to re-engage user; it can be used when offline and behaves under poor network condition; it works with devices of wide ranging capabilities and it's still evolving to works with new capabilities defined by open web standards; payment can be made by user inside PWAs apps; and PWAs apps are search-engine-friendly and work perfectly with hyper-links. PWAs are successful on both the technical aspect and business aspect (widely adopted by many web sites, esp. consumer facing ones).</p>
                        </dd>
                    </dl>
                </section> 
        </section>
        <section>
            <h2>Working with the Web</h2>
            <p>This section selects some typical use cases and proposes a few APIs that MiniApps would like to have support from the Web.</p>
            <section>
                <h2>Application Lifecycle</h2>
            <section>
                <h2>Hybrid Rendering</h2>
                <p>MiniApp is a hybrid solution of Web rendering and native rendering. It'd be great if there is a good way to combine the rendering results from the Web and from the native.</p>
                <figure>
                    <img alt="Rendering results coming from both the Web and the native" src="images/rendering.png" width="600">
                    <figcaption>
                        Rendering results coming from both the Web and the native
                    </figcaption>
                </figure>
                <p>Proposal: Mini App needs a standardized API to help integrate the native rendering result into Web rendering result.</p>
            </section>
            <section>
            <h2>Transition Animation</h2>
                <p>MiniApp would like to provide transition animation during page switching so that users can have similar experience as when they are using a native app, but it's almost impossible to do that now.</p>
                <p>Proposal: Mini App needs an API to call add transition animation during MiniApp page switching.</p>
            </section>
            <section>
            <h2>Standardise the Package Constructor of MiniApp</h2>
                <p>MiniApp can form a package and parsing convention for multiple MiniApp hosting platforms through a standardized distribution format. Currently, each MiniApp hosting platform provides different development tools (different packaging methods), and the MiniApp is parsed differently in different MiniApp hosting environments.</p>
                <p>Proposal: The MiniApp is actually a packaged (compressed) collection of files during the distribution process. We can describe a MiniApp (.ma) with a uniform file suffix and specify how to create the .ma file and how to parse the .ma file.</p>
            </section>
            <section>
            <h2>Standardise the navigation to a MiniApp page</h2>
                <p>For a hot page in a MiniApp, it may be referenced in another MiniApp, and it is expected to be accurately evoked when the user visits.</p>
                <p>Proposal: Define a standardized protocol (URI scheme) to access MiniApp.</p>
            </section>
            <section>
            <h2>MiniApp Widgets</h2>
                <p>Like Android widgets or apple dashboard, users can directly get information and/or finish their task by a MiniApp widget without opening any web or app pages. A MiniApp widget can be displayed in an environment outside of web browsers, such as desktop or dashboard.</p>
                <p>Proposal:</p>
                    <ul>
                        <li>A MiniApp widget can be displayed within a host environment, which could be either webview or a native app page. The host environment loads a widget with its corresponding URI path, which describes a package and widget page.</li>
                        <li>A MiniApp widget can access local data or data from server.  Meanwhile, a MiniApp widget can communicate with MiniApp in the same package.</li>
                        <li>A MiniApp widget should be interactive, meaning that it should be responsive to any user behaviors/interactions. A MiniApp widget should have the ability to open a web or app page.</li>
                    </ul>
            </section>
            </section>

            <section>
                <h2>Performance and Tuning</h2>
            <section>
                <h2>Define an event of time to interactive in MiniApp</h2>
                <p>MiniApp needs to know when the MiniApp page Time to Interactive (TTI) has been completed.</p>
                <p>Proposal: A standardized event to notify that the MiniApp page Time to Interactive has been completed.</p>
            </section>
        </section>

        <section>
                <h2>Graphics and Media</h2>
            <section>
                <h2>3D Model Element</h2>
                <p>3D models become more and more popular thanks to its rich details, and combined with AR, it will provide a much better user experience than 2D.  The business cases might include online shopping, advertisement, education, etc. However, the current web lacks a standard and convenient way to deal with 3D model.  In this document, we propose to define a HTML tag to directly handle 3D model, similar to the way we handle audio, video, image with corresponding HTML tags:</p>
                    <ul>
                        <li>360 view
                            <p>User can view a 3D model from different angles via gestures. And the 3D model can be zoom in/out as well. It can be viewed in full screen, or it can be embedded in a HTML page, shown together w/ other HTML contents.</p>
                        </li>
                        <li>View with AR
                            <p>User can place the 3D model in the real world environment with camera.  User can specify different locations to place the model.</p>
                        </li>
                    </ul>
                <p>Proposal: A <code>&lt;xmodel></code> Element to specify a 3D model on the Web and to power interactive 3D contents with AR.</p>
            </section>

            <section>
                <h2>Face Tracking</h2>
                <p>Face tracking can be used in many 3D scenarios.</p>
                <dl>
                        <dt>Face Effects in Live Video</dt>
                        <dd>
                            Add effects on the face in live video. These effects include full-screen filter, face reshape and makeup, 2d sticker, 3d headdress, etc. Most of these effects depend heavily on the real-time face tracking from video source.
                        </dd>
                        <dt>Gaming</dt>
                        <dd>
                            Game developers can design game strategies based on the tracked face. Like triggering a specific game logic when the eye is blinked, or check if the dropping fruit is in the opened mouth.
                          </dd>
                        <dt>Virtual Makeup</dt>
                        <dd>
                          Let users try lipsticks, eye shadows, glasses, hats on the product page to help them make the decision.
                        </dd>
                </dl><p>Proposal: A Face Tracking API use a video element as input and updates face tracking output every frame, which includes:
                    <ul>
                        <li>Bounding box of each face
                        </li>
                        <li>4x4 pose matrix of each face
                        </li>
                        <li>Normalized (x, y) landmarks points
                        </li>
                        <li>ace geometry data including vertices, normals, texture coordinates
                        </li>
                    </ul>
            </section>

            <section>
                <h2>Hand gestures tracking and recognition</h2>
                <p>Hand gestures can be used in video effect and AR/VR games scenario which can make apps more impressive and interactive.</p>
                <p>Proposal: A high-level API to track hands movement, get hands outline.</p>
            </section>

            <section>
              <h2>Low level AR APIs based on ARCore and ARKit</h2>
              <p>There are a few AR APIs in MiniApps we would migrate to the Web, as they help to provide better AR experience in gaming, 3d model preview, interactive ads.</p>
              <p>Proposal: Provide low-level AR APIs based on ARCore and ARKit, which includes:</p>
              <dl>
              <dt>Camera view matrix for world tracking</dt>
              <dd>Provide the 4x4 view matrix of the spatial location and orientation of the mobile phone, which can be used to update the camera matrix in their 3D virtual world in real time by developers. Thereby the position of the real world can be correlated with the position of the object in the virtual world.</dd>
              <dt>Plane detection and tracking</dt>
              <dd>Detect planes in the real world and track these planes in real-time. Provide the 4x4 transform matrix which represents the center position and orientation of each plane. It can be used for placing 3D virtual object on the ground/desktop.</dd>
              <dt>Anchor</dt>
              <dd>Anchor defines a fixed position and orientation in the real world. Developers can create an anchor from a 4x4 transform matrix, which can be got by hit test. This matrix will be updated each frame to ensure that the virtual object corresponding to the matrix can be fixed in one position and direction in the real scene.</dd>
              <dt>Hit test</dt>
              <dd>Get a 4x4 transform matrix representing a position and orientation in the real world space corresponding to the screen position to implement functions such as clicking and placing virtual objects.</dd>
              </dl>
                <figure>
                    <img alt="Better support for AR" src="images/ar_support.png" width="600">
                    <figcaption>
                        APIs to better support AR
                    </figcaption>
                </figure>
            </section>
        </section>
        </section>

        <section>
          <h2>Current standards work, the WG work</h2>
          <section>
            <h2>Lifecycle</h2>
            <p>[[MINIAPP-LIFECYCLE]] defines the MiniApp lifecycle events and the process to manage MiniApp and each page's lifecycle. Implementing this specification enables the user agent to manage the lifecycle events of both the global application lifecycle and the page lifecycle.</p>

            <p>As described in [[[#separate-the-view-layer-from-the-logic-layer]]], in a MiniApp, the View layer is separated from the Logic layer. The View layer is responsible for rendering MiniApp pages, including Web rendering and native rendering, which can be considered as hybrid rendering. The Logic layer is implemented with JavaScript Worker. The Logic layer is responsible for MiniApp’s event processing, API calling, and lifecycle management.</p>

            <p>MiniApp lifecycle mechanism provides a means to manage MiniApp's View layer and Logic layer through the MiniApp global application lifecycle events and MiniApp page lifecycle events. Developing MiniApp with knowledge of the MiniApp global application lifecycle states and MiniApp page lifecycle states can lead to improved user experiences. MiniApp lifecycle includes a set of events, with which MiniApp can choose to alter its behavior based on its state.</p>
          </section>

          <section>
            <h2>Manifest</h2>
            <p>[[MINIAPP-MANIFEST]] is the specification that defines the set of metadata to describe MiniApps. The MiniApp Manifest extends the [[APPMANIFEST]] and the [[MANIFEST-APP-INFO]] specifications by providing additional mechanisms to set up basic information of a MiniApp, like identification, human-readable descriptions, versioning data, and styling information. The MiniApp manifest also configures the routing of the pages and widgets that are part of a MiniApp. 
            </p>

            <p>A MiniApp manifest is a JSON document that uses some basic elements of the Web App Manifest to describe a MiniApp (<code>name</code>, <code>short_name</code>, <code>description</code>, and <code>icons</code>), adding nine supplementary members to specify technical details about the MiniApp (<code>app_id</code>, <code>version</code>, <code>platform_version</code>, <code>device_type</code>, <code>pages</code>, <code>req_permissions</code>, and <code>widgets</code>) and configure the look and feel of the app (<code>color_scheme</code> and <code>window</code>).
            </p>
          </section>

          <section>
            <h2>Packaging</h2>
            <p>[[MINIAPP-PACKAGING]] defines the semantics and conformance requirements for a MiniApp package and the structure of the container that holds the resources of a MiniApp, including the page components (i.e., templates, stylesheets, and JavaScript logic), the manifest, and other media files or configuration resources.
            </p>

            <p>This specification determines the logic and physical structures of MiniApps, holding the requirements in terms of file system organization and processing of the ZIP-based container that packs a MiniApp. Instances of the MiniApp package facilitate the MiniApp distribution and execution in runtime environments or MiniApp user agents.
            </p>
          </section>

          <section>
            <h2>Addressing</h2>
            <p>[[MINIAPP-ADDRESSING]] is a Note defines a standard MiniApp protocol for accessing MiniApps. It aims to solve the problem that currently, each MiniApp vendor has its own way to describe a MiniApp resource, and uses very different methods to obtain the MiniApp package, which makes it very difficult to access MiniApps across platforms and difficult to reach a unified understanding from both user and developer perspectives.</p>
            <p>The document refers to mobile deep linking technology and defines two ways to access MiniApp, one with the HTTPS protocol and the other with a custom protocol. In addition, MiniApp Addressing defines the syntax of MiniApp URIs, including uri-prefix for cross-environment access, uri-infix "miniapp" for MiniApps, and id and version to uniquely identify a MiniApp.</p>
            <p>MiniApp Addressing also describes how the user agent obtains the corresponding mini-app package based on MiniApp URI, as well as some error handling, and gives an example procedure for downloading MiniApp packages over the network. </p>
            </p>
          </section>

          <section>
            <h2>Widget</h2>
            <p>MiniApp Widget is a special form of MiniApp Page. Same as a page, a widget runs in a host environment that is called the User Agent. Unlike a page, a widget can occupy a certain area instead of the entire screen. The [[MINIAPP-WIDGET-REQ]] document describes the initial design considerations for developing a MiniApp Widget, including user agent, packaging, manifest, addressing, lifecyle, UI components, API, and communication between MiniApp and MiniApp Widget etc. The detailed Widget Specification will be described in a separate document, which will describe the detailed technical requirement and capabilities of User Agent. For example, the potential dependencies of Widget running environment, the potential changes of API and UI Components brought by Widget, new features bright by Widget such as requirement of communication between MiniApp and MiniApp Widget. Both User Agent developers and Widget developers can refer to the Widget Specification for technical development.
            </p>
          </section>

          <section>
            <h2>Implementation, converting tools</h2>
            <p>In 2021, the Working Group published two documents, [[MINIAPP-MANIFEST]] and [[MINIAPP-LIFECYCLE]]. Meanwhile, various vendors have some pre-standard implementations. To verify the feasibility of the standards, and to be compatible with pre-standard implementations, the working group developed a tool for converting MiniApp standard Manifest to different pre-standard manifest files, such as Baidu's <code>App.json</code> and HarmonyOS FA's <code>config.json</code>. And in a 2021 TPAC breakout session, the working group demonstrated a demo of the tool.</p>
            <p>As the standards and pre-deployment progress, the working group plans to refine the tools to support a complete, standardized development approach that may include Packaging, Addressing, Lifecycle, UI components, and APIs.
            </p>
          </section>

        </section>

        <section>
          <h2>New ideas incubated, the CG work</h2>
          <section>
            <h2>UI components</h2>
            <p>MiniApp components are the building blocks to define the structure, content, and logic of the pages that form a MiniApp. Each component encapsulates functionality, data, and styles, enabling developers to build reusable and customizable items.</p>
            <p>The MiniApp UI Components specification collects a set of essential elements that developers can use to build homogeneous but customized user interfaces across MiniApp platforms.</p>
            <p>This specification does not reference specific versions of HTML and CSS. It points to the latest W3C recommendations in order to guarantee the adoption and implementation of the changes to the HTML and CSS standards. Both MiniApp user agent vendors and developers will need to keep track of changes to these specifications to ensure that their processes and systems are kept up to date.</p>
            <p>This specification defines a set of predefined elements that are common in all the MiniApp specifications, based on Web Components.</p>
          </section>

          <section>
            <h2>MiniApps for IoT</h2>
            <p><a href="https://w3c.github.io/miniapp-iot">MiniApp for IoT</a> describes the use cases of MiniApp for IoT. Derived from the use cases, this specification defines the architecture of MiniApp for IoT. How to reuse and extend the MiniApp Packaging and MiniApp Lifecycle is specified. Also, several APIs are specified for MiniApp APIs for IoT.</p>

            <p>MiniApp for IoT shares similar architecture of MiniApp running on the cell phone and PC. But since IoT device has different hardware capabilities, MiniApp for IoT has its unique features, including:</p>

            <ul>
            <li>MiniApp Packaging for IoT</li>
            <li>MiniApp Lifecycle for IoT</li>
            <li>MiniApp APIs for IoT</li>
            </ul>
          </section>
        </section>

          <section>
                <h2>Security and Privacy Consideration</h2>
                <p>MiniApp utilizes HTTPs to support secure connection. Multiple MiniApps within same host environment are independent with each other.</p>
                <p>User interactions within MiniApp needs different level of user permissions:
                </p>
                <table>
                      <tbody><tr>
                        <th>Permission</th>
                        <th>User Interactions</th>
                      </tr>
                      <tr>
                        <td>default(no extra action needed)</td>
                        <td>Page sharing, clipboard, vibration, compass, motion sensors, map, screen brightness, screen capture, battery status</td> 
                      </tr><tr>
                        <td>permission on first-time usage</td>
                        <td>Geolocation, camera(qr code), network status, Bluetooth, NFC</td> 
                      </tr><tr>
                        <td>permission on every usage</td>
                        <td>Contacts, file-apis, add to home screen, photo picker, phone call</td> 
                      </tr><tr>
                        <td>Validate with token</td>
                        <td>Push</td> 
                      </tr><tr>
                        <td>Callback/messaging</td>
                        <td>Password-free Payment</td> 
                      </tr><tr>
                        <td>request password</td>
                        <td>Payment</td> 
                      </tr>
                    </tbody>
                  </table>
                  <p>
                    From different perspectives and according to different security levels, the MiniApp framework provides the following methods.
                  </p>

                  <section>
                    <h2>Capability authentication</h2>
                    <p>
                      For capabilities with high privacy risks, MiniApp requires developers to apply for permission to use such capabilities on the MiniApp Developer Platform. The application includes application reason, a detailed description of the usage scenario, and the demo of usage. Then the platform will review applications according to the MiniApp usage requirements.  Only approved MiniApps are allowed to invoke such interfaces. For example, the ability to obtain the user's mobile phone number is one of the capabilities with high security risks. 
                    </p>
                  </section>

                  <section>
                    <h2>
                      User Authorization
                    </h2>
                    <p>
                      For interfaces involving user privacy, the user's authorization must be required.  MiniApp classifies these sensible interfaces into several authorization <dfn>scopes</dfn> such as <em>location</em>, <em>album</em>, <em>address</em>, <em>camera</em>, <em>calendar</em>, and so on. For example, a window will be popped up like below when the MiniApp tries to invoke the camera capability but users don't authorize it and users would understand that such privacy-related capability is actually being protected.  Meanwhile, MiniApps hosted by different <a>super apps</a> might have some different privacy authorization <a>scopes</a> based on the usage characteristics and usage scenarios of each <a>super app</a>.
                    </p>
                    <figure>
                      <img alt="User Authorization" src="images/user_authorization.png" width="400">
                      <figcaption>
                        User Authorization
                      </figcaption>
                    </figure>
                  </section>

                  <section>
                    <h2>
                      MiniApp Audit Review
                    </h2>
                    <p>
                      All MiniApps packages will be reviewed by MiniApp platforms before publishing. Developers must follow MiniApp Platform Operation Terms because the platform is the only way for them to publish a new version MiniApp. There are many aspects of platform auditing such as data collection, data use, data security and geographic location.
                    </p>
                  </section>

                  <section>
                    <h2>
                      Domain check
                    </h2>
                    <p>
                      For some container components where could render an online web page like <code>&lt;web-view></code>, MiniApp has limitations to the URL opened by the component. Only the domain configured in the MiniApp Management Center can be accessed in <code>&lt;web-view></code>. Also, if the component contains an <code>&lt;iframe></code>, the URL opened by the iframe should also be configured in the MiniApp Management Center. In this way, MiniApp platform can have stronger control over the dynamic pages opened by the MiniApp.
                    </p>
                    <p>
                      Similarly, the MiniApp framework verifies the legitimacy of asynchronous request address.
                    </p>
                    <p>
                      For example, for URLs launched by request, download, upload, etc., their domain must belong to the domain configured in the MiniApp Management Center, and their protocols must be HTTPS protocols to ensure the security of data transmission.
                    </p>
                  </section>
            </section>

            <section>
              <h2>MiniApp Standardization in the Globe</h2>
              <p>
                Though it originated in China, MiniApp is increasing in popularity around the globe. Similar product forms are raised in other parts of the world, including Japan, Korea, Southeast Asia, the US, Europe, and Africa. The standardization of MiniApp technologies has drawn considerable attention from the global Web community. Thus, the collaboration on MiniApp standards becomes a joint international effort.
              </p>
              <section>
                <h2>Broader Web Community Discussions on MiniApp</h2>
                <p>The first global Web community discussion on MiniApp standardization was during <a href="https://www.w3.org/2019/09/TPAC/">TPAC 2019</a> in Fukuoka. A <a href="https://www.w3.org/2019/09/18-miniapp-minutes.html">breakout session</a> was organized during which MiniApp vendors introduced MiniApp technologies and the necessity for MiniApp standards. The participants discussed the possible directions for MiniApp standardizing such as packaging, manifest, lifecycle, and widget. Special efforts were made to avoid the overlapping between MiniApp standards and the current Web standards efforts, and enhance the interoperability between MiniApp platforms and the Web, and between different MiniApp platforms. The <a href="https://www.w3.org/community/miniapps/">MiniApps Ecosystem Community Group</a> was launched right after this discussion and the incubation of MiniApp specifications started.</p>
                <p>During virtual <a href="https://www.w3.org/2020/10/TPAC/">TPAC 2020</a>, there was a breakout session titled <i><a href="https://www.w3.org/2020/10/28-miniappslearnings-minutes.html">Learning from Mini Apps</a></i> at the event. In this breakout session, experts discussed the abstract form of a MiniApp and the powerful features that MiniApps can have. Also, the session shared how one could build a MiniApp via various development tools. Then there was an open discussion focused on what Web developers can learn from MiniApp and their developer experience. </p>
              </section>

              <section>
                <h2>MiniApp in CJK</h2>
                <p>
                  MiniApp product forms and technologies in Asian markets share lots of similarities. To gather the global community, especially the Chinese, Japanese and Korean participants, to communicate around the MiniApp ecosystem in each area and discuss the future of standardization effort on MiniApps, W3C <a href="https://www.w3.org/2021/miniapps/">MiniApps Working Group</a> and <a href="https://www.w3.org/community/miniapps/">MiniApps Ecosystem Community Group</a> organized <a href="https://www.w3.org/2021/03/miniapp-cjk/index.html">the 1st CJK Meeting on MiniApps</a> in April 2021. About 90 participants from over 30 organizations joined the discussion and exchanged ideas about MiniApp ecosystems, technical architecture, frameworks and MiniApps in new scenarios such as MiniApp for vehicles. Rough conclusion about the discussion is that as the development of MiniApp standards go on well in the MiniApps Working Group, it’s time to start the horizontal review of security, privacy, accessibility as well as internationalization of MiniApp standards; also, leveraging IoT technologies in MiniApp can be a very promising direction for the for MiniApp in new scenarios and there will be good opportunity for the global MiniApp community to cooperate on the related standardization work. 
                </p>
              </section>

              <section>
                <h2>MiniApps in Europe</h2>
                  <p>Although there are only a few cases of MiniApps in Europe, this concept is gaining traction; and the community has started to explore these technologies, looking for new business models and innovations out of the traditional app marketplaces.</p>
                  <p>In 2021, a group of stakeholders, including three W3C Members, launched the <a rel="nofollow" href="https://quick-app-initiative.ow2.io/">Quick App Initiative</a>, an open-source-oriented interest group open to any organization and individual and driven by open collaboration. This group, hosted by OW2, an independent non-profit organization based in France, is ruled under a transparent process intending to promote the W3C works from a vendor-neutral perspective and focused on outreach, implementations, and standardization requirements gathering from the European market perspective.</p>
              </section>

            </section>

            <section>
                <h2>Way Forward in W3C</h2>
                <p>To meet the use cases and requirements of MiniApps, make the Web standards better support the MiniApp, and explore innovation of user agent and  enrich the Web, we hope to set up a group and include the following work in W3C:</p><ul>
                        <li>coordinate the MiniApp related standardization in W3C as well as to collaborate with other related W3C groups.
                        </li>
                        <li>horizontal review (security, privacy, i18n and a11y).
                        </li>
                    </ul>

                    <p>In details, the following technical work shall be studied further:</p><ul>
                        <li>draft a roadmap for MiniApp standards based on the use cases and requirements selected by the group.
                        </li>
                        <li>develop specifications for  features among current vendors. Target features include but not limited to:
                            <ul>
                        <li>package constructor</li>
                        <li>MiniApp URI scheme</li>
                        <li>hybrid rendering API</li>
                        <li>3D model tag</li>
                        <li>face tracking API </li>
                        <li>Widget</li>
                    </ul>
                        </li>
                        <li>design future Web APIs to be useful for both web and MiniApp environments.</li>
                    </ul>
                 <p>Note: the further gap between current MiniApp APIs and Web APIs will be analyzed in parallel.</p>
            </section>

            <section id="glossary">
                <h2>Glossary</h2>
                <table class="glossary">
                  <thead>
                      <tr>
                        <th>Chinese</th>
                        <th>English</th>
                        <th>Definition</th>
                      </tr>
                    </thead>
                      <tbody>
                      <tr id="term.mini-program">
                        <td>小程序</td>
                        <td>Mini Program</td> 
                        <td>One format of MiniApp running within native apps.</td> 
                      </tr>
                      <tr id="term.quick-app">
                        <td>快应用</td>
                        <td>Quick App</td>
                        <td>A MiniApp standard developed by 12 mobile phone manufacturers in Quick App alliances.</td> 
                      </tr>
                      <tr id="term.rendering-view">
                        <td>渲染环境</td>
                        <td>rendering view</td>
                        <td>Native view or WebView.</td>
                      </tr>
                      <tr id="term.smart-assistant">
                        <td>智能助理（负一屏）</td>
                        <td>smart assistant</td> 
                        <td>A smart assistant to provide service for convenience, usually at left of the home screen.</td> 
                      </tr>
                      <tr id="term.hot-reload">
                        <td>热更新</td>
                        <td>hot reload</td>
                        <td>No need to be re-installed when fixing or updating feature. In MiniApps, since a part of framework is implemented in JavaScript, MiniApp runtime can be hot reloaded.</td>
                      </tr>
                    </tbody></table>
            </section>

    <section class="appendix">
      <h2>
        Gap Analysis
      </h2>
      <p>
        Please look at <a href="comparison.html">the comparison table of APIs in MiniApps, W3C specs, and PWAs</a>.
      </p>
    </section>

            <section class="appendix">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Many thanks to Guanyu Liu (360), He Du (Xiaomi), Hongguang Dong (Xiaomi), Xiaoqian Wu (W3C), Yi Shen (Baidu), Yefeng Xia (China Mobile) who also contributed to this document.
      </p>
    </section>
</body>

</html>
