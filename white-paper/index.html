<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>MiniApp Standardization White Paper version 2</title>

    <style>
    .two-cols {
      display: grid;
      grid-template-columns: 1fr 1fr;
    }

    table {
      border-collapse: collapse;
    }

    table, th, td {
      border: 1px solid #666;
    }

    th, td {
      padding:2px 15px;
    }
    </style>

    <script async class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>

    <script class="remove">
        var respecConfig = {
            specStatus: "ED",
            previousPublishDate: "2019-09-12",
            previousMaturity: "WD",
            copyrightStart: "2019",
            edDraftURI: "https://w3c.github.io/miniapp/white-paper/",

            shortName: "mini-app-white-paper",
            noRecTrack: true,
            copyrightStart: "2019",

            editors: [{
                name: "Qing An",
                companyURL: "https://www.alibabagroup.com/en/global/home",
                company: "Alibaba",
                w3cid: 76701
              }, {
                name: "Dan Zhou",
                companyURL: "https://www.baidu.com/",
                company: "Baidu, Inc",
                w3cid: 118521
              }, {
                name: "Martin Alvarez-Espinar",
                companyURL: "https://www.huawei.com/",
                company: "Huawei",
                w3cid: 125049,
              }, {
                name: "Zitao Wang",
                companyURL: "https://www.huawei.com/",
                company: "Huawei",
                w3cid: 124483
              }, {
                name: "Wanming Lin",
                companyURL: "https://www.intel.com/",
                company: "Intel Corporation",
                w3cid: 91067
              }, {
                name: "Kaining Yuan",
                companyURL: "https://www.intel.com/",
                company: "Intel Corporation",
                w3cid: 118212
              }, {
                name: "Canfeng Chen",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi",
                w3cid: 124040
              }, {
                name: "Yinli Chen",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi",
                w3cid: 117298
              }, {
                name: "Anqi Li",
                companyURL: "https://www.w3.org/",
                company: "W3C",
                w3cid: 40190
              }, {
                name: "Fuqiao Xue",
                companyURL: "https://www.w3.org/",
                company: "W3C",
                w3cid: 95475
              }],

              formerEditors: [{
                name: "Dapeng Liu",
                companyURL: "https://www.alibabagroup.com/en/global/home",
                company: "Alibaba",
                w3cid: 76699
              }, {
                name: "Hongru Zhu",
                companyURL: "https://www.alibabagroup.com/en/global/home",
                company: "Alibaba",
                w3cid: 76462
              }, {
                name: "Qingqian Tao",
                companyURL: "https://www.baidu.com/",
                company: "Baidu, Inc",
                w3cid: 101978
              }, {
                name: "Zhixing Lei",
                companyURL: "https://www.baidu.com/",
                company: "Baidu, Inc",
                w3cid: 53404
              }, {
                name: "Lei Zhao",
                companyURL: "https://www.10086.cn/",
                company: "China Mobile",
                w3cid: 110287
              }, {
                name: "Zhiqiang Yu",
                companyURL: "https://www.huawei.com/",
                company: "Huawei",
                w3cid: 102877
              }, {
                name: "Xiaowei Jiang",
                companyURL: "https://www.mi.com/",
                company: "Xiaomi",
                w3cid: 115244
              }],

            group: "wg/miniapps",
            wgPublicList: "public-miniapps-wg",

            github: "w3c/miniapp"
        };
    </script>
</head>

<body>
    <section id='abstract'>
        <p>
        This document introduces a new format for mobile applications, named MiniApp, which is a very popular hybrid solution relying on Web technologies but also integrates with capabilities of the native apps.
        </p>
    </section>
    <section id='sotd'>
    </section>

    <section>
        <h2>Introduction</h2>
        <section>
            <h2>Problems</h2>
            <p>Native apps are well received in our daily life, but there are still many things that can be done better for users.</p>
            <ul>
                <li>
                    <p>Before users get the service from a native app, they often have to go through the process of downloading -> installing -> registering the app.</p>
                    <p>Users can only keep a limited number of native apps on their phones due to the constraints of storage capability.</p>
                    <p>It's not easy to share data between different native apps.</p>
                </li>
                <li>
                    <p>To work on a native app, developers may need to learn a few new programming languages.</p>
                    <p>To provide the same service as native apps, developers may need to maintain duplicate products for different platforms.</p>
                </li>
            </ul>
            <p>The Web is an ideal platform to avoid these problems, but it's still imperfect by far.</p>
            <ul>
                <li>
                    <p>Compared to the native, it isn't easy to take advantage of the capabilities provided by the system. </p>
                    <p>Also, it's usually difficult to design a Web application whose performance can actually match or surpass a similar native app.</p>
                </li>
                <li>
                    <p>On a mobile device, users frequently obtain services or contents outside the browser; naturally, they would like all their applications to be consistent on user accounts, login status, and user interaction across the whole system.</p>
                    <p>Moreover, sometimes users may want to share some data with an application if they really trust it. Still, for a few frequently requested information, such as the personal mobile number of the current device, or the contact list, there isn't a good way for the users to give permits on the Web.</p>
                </li>
            </ul>
        </section>
        <section>
            <h2>What is MiniApp?</h2>
                <p>MiniApp is a new mobile application format, a hybrid solution that relies on Web technologies (especially CSS and JavaScript) and integrates with the capabilities of native apps.</p>
                <p>A <dfn>super app</dfn> is a software platform that hosts and supports other applications (i.e., MiniApps), enabling their execution by using the platform's resources.</p>
                <p>MiniApps got popular from their usage on a few <a>super apps</a>, as it was born with a few characters that helped fill the gap between the Web and the native.</p>
                <ul>
                    <li>It's free of installation.</li>
                    <li>Multiple WebViews to improve performance.</li>
                    <li>It provides a few mechanisms to access OS capabilities or data through the native.</li>
                    <li>The content is usually more trustworthy because the app needs to be validated by the platform.</li>
                    <li>A MiniApp can be distributed to multiple MiniApp platforms (the Web, a native app, even the OS). These platforms also provide entry to the MiniApp to ensure the users can easily discover it.</li>
                </ul>
            </section>
            <section>
                <h2>Gap between MiniApps and PWA</h2>
                <p>MiniApps are <em>not</em> aimed to replace PWA, the Web, or the native apps.</p>
<p>MiniApps and PWAs are composed of the same resources (i.e., scripts, markup-language-based documents, stylesheets, multimedia, etc.). The type of documents and their coding languages are similar, but MiniApps implement specific dialects and built-in services that are not standard. </p>
<p>Apart from the format, MiniApp's resources are usually packed in a self-contained physical structure that enables a flexible distribution from app marketplaces to offline exchange. </p>
<p>The main difference between PWAs and MiniApps is the execution environment. MiniApp user agents are <a>super apps</a> or platforms implemented on the operating system, while PWA user agents are usually Web browsers.  </p>
<p>Although both technologies have similar APIs and services, there is a significant gap between the API specifications in each application type. PWAs rely on standard Web APIs, while MiniApps implement non-standard APIs to maximize the platform's capabilities, such as device-specific features and vendor-exclusive services.  </p>
<p>MiniApp vendors define similar UI (User Interface) elements that do not always have a direct equivalent in HTML. </p>
<p>Depending on the implementation, a MiniApp user agent could be an operating system, a <a>super app</a>, or any other hosting platform based on different and various rendering engines and WebViews. The architecture of a MiniApp user agent differs from PWA user agents, as we can see in the following picture.</p>

<figure>
  <img alt="The architecture of MiniApps and PWA" src="images/miniapp_pwa.svg" width="800">
  <figcaption>
    The architecture of MiniApps and PWA
  </figcaption>
</figure>

<p>
  The main differences between them can be summarized in the following table.
</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Progressive Web App</th>
      <th>MiniApp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Source code</td>
      <td>Standard markup languages (HTML), stylesheets (CSS), and scripts (JavaScript). </td>
      <td>Non-standard dialects of HTML, CSS and JavaScript</td>
    </tr>
    <tr>
      <td>Deployed Format</td>
      <td>Web resources (mainly: HTML, CSS, JavaScript code, and WebAssembly modules)</td>
      <td>HTML, CSS, JavaScript, and other resources packed in a container. </td>
    </tr>
    <tr>
      <td>Packaging</td>
      <td>No. Resources linked on the Web.</td>
      <td>Yes. Different package formats per vendor.</td>
    </tr>
    <tr>
      <td>Needs to host files on Web server</td>
      <td>Yes </td>
      <td>No</td>
    </tr>
    <tr>
      <td>Installation-free usage</td>
      <td>Yes, running in the browser.</td>
      <td>Running in a <a>super app</a> or on the OS.</td>
    </tr>
    <tr>
      <td>Installation with standalone icon</td>
      <td>From the browser or app store (optional)</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Services </td>
      <td>Access to Web APIs</td>
      <td>Access to non-standard Web APIs, including some system native APIs</td>
    </tr>
  </tbody>
  </table>

            </section>
            <section>
                <h2>Case studies</h2>
                <section>
                    <h2>Case 1: Shared Bicycle Service</h2>
                    <p>The popularization of MiniApps helps make the shared bike a seamless service instead of a cumbersome application.</p>
                    <div class="two-cols">
                    <ul>
                        <li>A user chooses any of the MiniApp platforms on their mobile device, which is usually a <a>super app</a> that they already logged in to;</li>
                        <li>A user scans the QR-code label attached to a shared bicycle within the <a>super app</a>;</li>
                        <li>The hosted app will automatically navigate to the shared bicycle MiniApp and unlocks the bicycle instantly;</li>
                        <li>Upon arrival, the user locks the bike on the MiniApp;</li>
                        <li>The transaction completes, and a message of the payment detail is sent to the user.</li>
                    </ul>
                    <figure>
                      <img alt="Shared Bicycle Service" src="images/shared_bike.png" width="200">
                      <figcaption>
                        Shared Bicycle Service with MiniApp
                      </figcaption>
                    </figure>
                    </div>
                    <p>For users, MiniApps can bring convenience from a few perspectives:</p>
                    <table>
                      <tbody><tr>
                        <th></th>
                        <th>The Web</th> 
                        <th>Native app</th>
                        <th>MiniApp</th> 
                      </tr>
                      <tr>
                        <td>Download/install</td>
                        <td>No</td> 
                        <td>Yes</td>
                        <td>No</td> 
                      </tr>
                      <tr>
                        <td>Verified/trusted</td>
                        <td>No</td> 
                        <td>Yes</td>
                        <td>Yes</td>
                      </tr>
                      <tr>
                        <td>Login/register</td>
                        <td>Yes</td> 
                        <td>Yes</td>
                        <td>User permission</td>
                      </tr>
                      <tr>
                        <td>Payment</td>
                        <td>Send a payment request</td> 
                        <td>Register a credit card or navigate to another app</td>
                        <td>Complete within the hosted app</td>
                      </tr>
                    </tbody></table>

                </section>

                <section>
                    <h2>Case 2: AR Zoo</h2>
                    <p>MiniApp developers can simply use HTML/CSS/JavaScript as the programming language, but MiniApp is more flexible, so it excels at quickly developing complex features in daily work.</p>
                    <p>This MiniApp tries to build an AR zoo with AI technologies to recognize the animals. Developers can easily do that by adding a few components or APIs that provide access to the native capabilities or advanced features (e.g., image recognition, AR 3D animal-model rendering, a speech API for speech synthesis, and AR navigation provided by the map SDK).</p>
                    <p>MiniApps can be discovered by the search engines, by search engines, MiniApp stores in the hosted app, or QR codes.
                    <figure>
                      <img alt="AR zoo" src="images/ar_zoo.png" width="600">
                      <figcaption>
                        AR Zoo MiniApp
                      </figcaption>
                    </figure>
                    <p>For the developers, the incentive to work on MiniApps is very obvious.</p>
                    <table>
                      <tbody><tr>
                        <th></th>
                        <th>The Web</th> 
                        <th>Native app</th>
                        <th>MiniApp</th> 
                      </tr>
                      <tr>
                        <td>Discoverability</td>
                        <td>Search engine</td> 
                        <td>Marketplace</td>
                        <td>Multiple: search engines + MiniApp store in the hosted apps + QR code</td> 
                      </tr>
                      <tr>
                        <td>Verified/Trusted</td>
                        <td>Still exploring</td> 
                        <td>By native app marketplaces</td>
                        <td>By host app platforms</td>
                      </tr>
                      <tr>
                        <td>Deploy/Reload</td>
                        <td>Load/reload the webpage</td> 
                        <td>Installed/reinstalled</td>
                        <td>Load/reload as it's using a JavaScript engine</td>
                      </tr>
                      <tr>
                        <td>Programming Language</td>
                        <td>Web programming language</td> 
                        <td>New/multi languages: iOS and Android, at least</td>
                        <td>Web programming language</td>
                      </tr>
                      <tr>
                        <td>APIs/Components (AR, Image Recognition, Geolocation, Speech API)</td>
                        <td>Very basic</td> 
                        <td>Complex for Web developers</td>
                        <td>Very simple high-level APIs and components</td>
                      </tr>
                    </tbody></table>
                </section>

                <section>
                    <h2>Case 3: MiniApp for Vehicle</h2>
                    <p>One of the goals of MiniApp is to connect information and services across different platforms, so it's ideal for IoT applications such as Smart Automotive, voice-control speakers, and Smart TV.</p>
                    <p>Nowadays, it's possible to convert some MiniApps to adapt the vehicle screen and system. Also, a few MiniApp vendors have built a MiniApp platform specially designed for the vehicle system to help distribute or upgrade applications to various car models. This brings millions of Web developers to the Automotive application ecosystem.</p>
                    <p>These Automotive MiniApps can service many user scenarios, including gas filling, car washing, electronic toll collection, insurance, restaurant reservation, or entertainment. For example, when the system detects the remaining fuel is less than 20%, it can recommend to the owner a Gas Pumping MiniApp. The user can get the information of the nearest gas station and head there to complete the gas pumping, including the payment within MiniApp, "refueling without getting off the vehicle".</p>
                    <figure>
                      <img alt="smart car" src="images/smart_cars.png" width="600">
                      <figcaption>
                        MiniApp for smart car (gas pumping app)
                      </figcaption>
                    </figure>
            </section>

            <section>
              <h2>Case 4: MiniApp for IoT</h2>
              <p>IoT device is becoming another carrier running MiniApps. MiniApp for IoT intends to enable interoperability across multiple IoT device platforms and operating systems. Rather than dealing with the difference across the multiple IoT device platforms and IoT operating systems, by introducing MiniApps for IoT, developers only need to focus on the application development on IoT devices.</p>

              <p>One example is the HVAC (heating, ventilating, and air-conditioning)
                application switch panel, which has a screen and several physical buttons. In this case, by introducing MiniApp for IoT, the switch panel’s screen UI can be designed and developed using Web technologies to display the HVAC information. For example, the target temperature value inputted by the physical and the measured real-time temperature value can be displayed.</p>
              <figure>
                <img alt="IoT MiniApp" src="images/hvac.png" width="300">
                <figcaption>
                  IoT MiniApp running on HVAC application switch panel having a screen and several physical buttons
                </figcaption>
              </figure>

              <p>
                Another example is smart speakers with a touch screen. In this case, by introducing MiniApp for IoT, the smart speaker’s touch screen UI can be designed and developed using Web technologies to play music and video, control the IoT devices at home, and shop online.
              </p>

              <figure>
                <img alt="IoT MiniApp on smart speaker" src="images/smart_speaker.png" width="300">
                <figcaption>
                  IoT MiniApp running on a smart speaker with a touch screen
                </figcaption>
              </figure>
      </section>

      <section>
        <h2>Case 5: MiniApp for TV</h2>
        <p>Unlike MiniApps running on mobile phones, where user interaction depends on the touch screen, the user interaction of MiniApps running on TV switches to the TV remote panel keyboard plus TV screen focus.
        </p>

        <p>With MiniApp for TV, users can buy merchandise on TV through E-commerce MiniApp.</p>
        <figure>
          <img alt="E-commerce MiniApp running on TV" src="images/tv_e_commerce.png" width="600">
          <figcaption>
            E-commerce MiniApp running on TV
          </figcaption>
        </figure>

        <p>
          And also, users can play games on TV through Gaming MiniApps.
        </p>

        <figure>
          <img alt="Gaming MiniApp running on TV" src="images/game_tv.png" width="600">
          <figcaption>
            Gaming MiniApp running on TV
          </figcaption>
        </figure>
        </section>

            </section>
        </section>
            <section>
                <h2>MiniApp Overview</h2>
                <section>
                    <h2>Core Features</h2>
                    <section id="separate-the-view-layer-from-the-logic-layer">
                        <h2>Separate the view layer from the logic layer</h2>
                        <p>In a MiniApp, the view layer is usually separated from the logic layer.</p>
                        <figure>
                          <img alt="Logic layer and view layer" src="images/logic_view.png" width="400">
                          <figcaption>
                            General architecture of MiniApps
                          </figcaption>
                        </figure>
                        <p>The view layer is responsible for rendering MiniApp pages, including Web components and native components display, which can be considered hybrid rendering. For example, some Web components might not be supported by the WebView or have performance limitations, so MiniApp also relies on native components such as map, video, etc.</p>
                        <p>The logic layer is implemented with JavaScript Workers. A worker is responsible for MiniApp’s event processing, API calls, and lifecycle management.</p>
                        <p>Extended native capabilities usually come from the hosting native app or OS, including payment, file processing, image scanning, phone calls, etc. These features are called through specific APIs. When a MiniApp calls a native API, it transfers the API call to extended native capabilities for further processing via a JavaScript Bridge. It obtains the result from the extended native capabilities via the JavaScript Bridge.</p>
                        <figure>
                          <img alt="data flow of MiniApp when an API is called" src="images/data_flow.png" width="600">
                          <figcaption>
                            Data flow of MiniApp when an API is called
                          </figcaption>
                        </figure>
                        <p>The worker establishes a connection for each Render, transferring the need-to-be-rendered data to the Render for further processing.</p>
                        <p>If an event is triggered by a component in a MiniApp page, this page’s Render will send the event to the worker for further processing. At the same time, the Render will wait for the data sent from the worker to re-render the MiniApp page.</p>
                        <p>The rendering can be considered stateless, and all the states will be stored in the worker.</p>
                        <p>The benefits of separating the view layer and the logic layer include:</p>
                        <ul>
                            <li>Very handy for data sharing and interaction among multiple MiniApp pages.</li>
                            <li>Having the same context within the lifecycle of MiniApp can provide a similar coding experience for those developers coming from native app development background.</li>
                            <li>Separation and parallel implementation of render and JavaScript worker can prevent the situation where a JavaScript execution impacts or slows down the page rendering, which can help enhance the rendering performance.</li>
                        </ul>
                    </section>
                    <section id="api_and_component">
                        <h2>Rich APIs and Components</h2>
                        <p>MiniApp platform provides many components to help developers build a fancy UI, including essential components like `view`, `form`, `image`, and high-level components like maps.</p>
                        <p>MiniApp vendors also offer many APIs for developers to access both the Web and the native capabilities, including basic interfaces such as UI display APIs, image processing API, and those advanced ones like user account API, map API, and payment API.</p>
                        <p>APIs usually work together with components. When a user clicks a certain component on a MiniApp page, it will call the related API to complete the user’s interaction and refresh the current MiniApp page if needed.</p>
                    </section>
                    <section id="constructor">
                        <h2>MiniApp Constructor</h2>
                        <p>In order to obtain similar user experiences as in native apps, MiniApp resources are usually packaged together. After downloading and installing a MiniApp package, all the static resources (i.e., page templates, CSS, JavaScript files, and other documents) required by the MiniApp persist on the users' devices. These resources are always available without any redundant downloads until the next update.</p>
                        <p>A MiniApp package is a compressed ZIP archive, including:</p>
                            <ul>
                                <li>A configuration document located in the root directory of the package. The config file should include:
                                    <ul>
                                        <li>the general description of the entire MiniApp; and</li>
                                        <li>the description of the pages, including their corresponding paths and configuration, for page setup and opening.</li>
                                    </ul></li>
                                    <li>One app-level logic file containing a script to deal with app-level lifecycle callbacks.</li>
                                    <li>One or several files, containing templates code for page structure, CSS stylesheets for page styling, and JavaScript codes for the page logic.</li>
                                    <li>Digital signature support for integrity validation.</li>
                            </ul>
                            <p>For the purpose of locating a specific MiniApp while searching and executing, a MiniApp must have a package name or an identifier on the platform. An icon is also required for user recognition.</p>
                    </section>
                    <section>
                        <h2>MiniApp Widgets</h2>
                        <p>In addition to MiniApp pages, MiniApps can also be displayed as information fragments or MiniApp widgets. In this form, developers can put their service and/or content to various host scenarios, called host environments (e.g., assistants, global search of the device, etc.). This feature connects the services and content of the MiniApp with the concrete scenario, providing users with more convenience.</p>
                        <p>For example, when a user purchases a train ticket for a trip, the MiniApp widget on the <a href="#term.smart-assistant">smart assistant</a> shows the train's latest status immediately. The user can click on this widget and jump to a full-screen MiniApp page for more detailed information.</p>
                        <figure>
                          <img alt="Widget from the home screen to a MiniApp" src="images/widget.png" width="600">
                          <figcaption>
                            Widget from the home screen to a MiniApp
                          </figcaption>
                        </figure>
                        <p>Like in a MiniApp page, a widget is also described by URI scheme. The host environment specifies the MiniApp package and the corresponding widget to be loaded through its URI path and passes data to the widget through URI query parameters. After the widget is loaded, it is displayed and rendered in the host environment. Data from the host and widget, as well as data from different widgets are isolated to ensure security and independence.</p>

                        <p>In many scenarios, a widget can open a MiniApp page for more complicated operations. In such cases, widgets often need to share data with their corresponding MiniApp (e.g., maintain a consistent login status). Therefore, the data of the widget and the MiniApp can be accessed from each side. In other words, the MiniApp widget and the page have same data access rights.</p>

                        <figure>
                          <img alt="widget interaction" src="images/widget_interaction.png" width="600">
                          <figcaption>
                            MiniApp widget interaction
                          </figcaption>
                        </figure>

                        <p>One of the goals of the widget is to let the user forget the traditional app concept and truly meet the user's needs in the form of service. So, in addition to all app invocation paths, widgets can also be triggered by different methods in different scenarios, such as text keywords, voice analysis, picture recognition, scan code, and event intent.</p>
                        <p>Note: Widget is implemented by Quick App in China market.</p>
                    </section>
                    <section>
                        <h2>Single-Instance, Multi-Entries</h2>
                        <p>There are multiple entrances to discover, open and access MiniApps. Unlike the Web content in multi WebViews, only one instance will be created for the same MiniApp, so MiniApp keeps its status and data in a consistent manner globally. For example, after one user opens and logs in to a MiniApp through the entrance of a QR code for the first time, the user will remain logged in the next time when the user returns from another entry like a MiniApp store.</p>
                        <p>The entries for MiniApps include, but are not limited to:</p>
                        <ul>
                            <li>MiniApp marketplace</li>
                            <li>Search engine</li>
                            <li>Smart assistant</li>
                            <li>QR code</li>
                            <li>SMS/text</li>
                            <li>Physical object (with AI)</li>
                            <li>Browser</li>
                            <li>Calendar items</li>
                            <li>Voice message (with AI)</li>
                        </ul>  
                    </section>
                    <section>
                        <h2>Performance and User Experience</h2>
                        <p>MiniApps try to improve their performance and user experience with a few mechanisms that have been proved to be effective through practice.
                        <dl>                            
                                <dt>Packaging</dt>
                                <dd><p>With <a href="#constructor">MiniApp's constructor</a>, a user only needs to download the package when the MiniApp is first opened, and then the static resources (e.g, pages, scripts, and CSS) in the MiniApp needn't be downloaded again, so that the loading and jumping of the following pages are more efficient. This feature improves user experience and saves network traffic.</p>
                                <p>Meanwhile, the MiniApp has a pre-download mechanism, which can download the MiniApp packages in advance, or pre-downloads separately for the first page, and perform streaming decompression in parallel during download to minimize the time-consuming of MiniApp startup phase and balance the loss of the first page performance when opening first time.</p>
                            </dd>
                                <dt>Multiple Rendering Views</dt>
                            <dd><p>The MiniApp uses native page stack management between render views, and the page switching is driven by native code. Therefore, the gesture operation in the page, the switching between pages can achieve the exact same smooth experience as native.</p>
                                <p>Because of the isolation of the view and logic layers, the view layer can be rendered independently. Without being blocked by JavaScript logic code, the rendering speed of the page can be greatly improved.</p>
                            </dd>
                                <dt>Pre-built and reuse of runtime environments</dt>
                            <dd>
                                <p>MiniApp's runtime environment is usually pre-built before launching a mini-app, thus reducing the time to launch a MiniApp. Pre-built content includes rendering views, static resources, developer-defined prefetch requests, and MiniApps runtime container. After a MiniApp is activated, it will take over the pre-built rendering view, and then we will continue to pre-build a new render view into the cache pool for the next one. There is a limit on render view quantity. When any render view gets closed or the quantity limit is exceeded, the oldest opened render view will be destroyed. When the MiniApp application exits, the runtime is destroyed, and the application environment and resources can be reused.</p>
                            </dd>
                                <dt>Pre-defined Component and API</dt>
                            <dd>
                                <p>MiniApp platforms provide very rich <a href="#api_and_component">components and APIs</a>. These components and APIs are usually well designed to meet the developers' performance requirements.</p>
                            </dd>
                                <dt>JavaScript framework presets and hot reload</dt>
                            <dd>
                                <p>MiniApp's runtime environment contains two major parts, the basic capabilities provided by native code and a framework, including developer API and some components implemented by JavaScript. The JavaScript framework is built in native apps and will be loaded into the MiniApp runtime environment in advance before executing the MiniApp. The JavaScript framework can be hot reloaded (reload during usage), which brings lots of possibilities to improve performance.</p>
                            </dd>
                        </dl>
                    </section>

                    <section>
                      <h2>Login</h2>
                      <p>
                        The MiniApp platforms provide a variety of ways for a user to log in to the MiniApp. If the user has already logged in to the platform with identity authentication, the login information of the platform can be shared with MiniApp, quickly realizing the interoperability of MiniApp’s own account system and the platform account system, which makes the access process of the MiniApp more smooth.
                      </p>
                      <p>
                        For example, the traditional login process with SMS verification is more time-consuming; users need to manually enter their cell phone number first and then enter the verification code after receiving the SMS to log in. The advantage of MiniApp is that developers can use the components / APIs provided by the platform to obtain users' cell phone numbers securely and conveniently, prompting the user to authorize a one-click login process with their cell phone numbers, which makes the entire process simple for the user and reduces the cost of obtaining user information for developers.
                      </p>
                      <figure>
                        <img alt="Sign in to a MiniApp" src="images/login.png" width="300">
                        <figcaption>
                          Sign in to a MiniApp
                        </figcaption>
                      </figure>
                  </section>

                  <section>
                    <h2>Subpackaging</h2>
<p>MiniApp subpackaging is a build mechanism for improving the MiniApp package development process. It helps developers divide different business modules into different subpackages.</p>
<p>For developers: a MiniApp has the main package by default; it contains the startup page files and public resources. Subpackage is a building type that flexibly divides the developer's business modules. Users can open special pages after loading different sub-packages on demand.</p>
<p>For users: when the user starts the MiniApp, the main package will be downloaded by default, and the page in the main package will be launched. If the user needs to open a page in the subpackage, the MiniApp Runtime will start to download and load the subpackage and start the subpackage page.</p>
<p>Through such a subpackage building mechanism is better to decouple and collaborate when multiple teams develop together. When users use the MiniApps, the subpackaging mechanism can improve the loading speed of the MiniApp homepage, load subpackages on demand, and optimize the user experience.</p>
                </section>

                <section>
                  <h2>Add-ons
                  </h2>
                  <p>In a MiniApp, an add-on/extension is an encapsulated module that adds a specific feature to an existing MiniApp, and it could be a component, a JavaScript module, or a page. The add-on/extension can only be executed in a MiniApp instead of running separately. Developers can develop an add-on/extension just like a MiniApp, and upload it to the MiniApp platform for other MiniApps to reuse.</p>
                  <p>MiniApp supports add-on/extensions to:</p>
                  <ul>
                  <li>reduce development costs by code reuse and help developers easily add new features</li>
                  <li>update functionality automatically without the awareness of developers</li>
                  <li>reduce the package size of MiniApps by not loading unused functions</li>
                  </ul>
                  <p>The add-on/extension mechanism lowers the barriers to developing MiniApps and brings more developers to the MiniApp ecosystem.</p>
              </section>
                </section>
                <section>
                    <h2>MiniApp Market</h2>
                    <p>This section describes a few current mainstream MiniApp or relevant platforms.</p>
                    <dl>
                        <dt>Alipay Mini Program</dt>
                        <dd>
                            <p>Alipay Mini Program runs on top of Alipay native app, which is a hybrid solution of Web and native. Alipay Mini Program relies on Web technologies like CSS and JavaScript. Meanwhile, it integrates the functionalities of Alipay native app as payment, credit service, face authentication, etc.</p>
                            <p>More than 1 million Mini Programs are running on Alipay native app, with 230 million DAU (Daily Active User). The user scenarios include retail, transportation, medical services, etc.</p>
                        </dd>
                        <dt>Baidu Smart Mini Program</dt>
                        <dd>
                            <p>Baidu Smart Mini Program refers to an open ecological product that intelligently connects people to information and services based on the Baidu app and other partners’ platforms. Through Baidu’s AI abilities and understanding of all contents in Smart Mini Programs, Baidu accurately connects users and Smart Mini Programs. With Baidu’s search and information flow dual engine, users can achieve an app-like experience within Smart Mini Programs. As of July 2019, there are over 150,000 Smart Mini Programs and 270 million MAU.</p>
                            <p>Baidu Smart Mini Program is open-sourced within our open source alliance, with more than 30 cooperators, covering <a>super apps</a>, mobile OS, car OS, voice-control speakers, and TV.</p>
                        </dd>
                        <dt>Quick Apps (Quick App Alliance, including Xiaomi and Huawei)</dt>
                        <dd>
                            <p>Quick App is a MiniApp standard developed by 12 top mobile phone manufacturers in the Quick App Alliance, covering over 200 million MAU. Developers can achieve one-time development and run on all hardware vendors' platforms. Quick Apps, which are deeply integrated into the operating system, can be obtained in multiple scenarios of the mobile phone system with just one click. By introducing a native rendering path, an effective combination of front-end development and native performance experience is achieved.</p>
                            <p>Quick Apps can run in two forms: Quick App page form, like native app page, and a widget form that presents information in the scene. The two are adapted to different user needs, connecting the system and the MiniApp into a whole in multiple scenarios.</p>
                        </dd>
                        <dt>360 PC MiniApp</dt>
                        <dd>
                            <p>MiniApps on PC is still in an early exploration stage. 360 PC MiniApp is a light application running in their PC browser. Compared to the traditional webpages, it's served with more functionalities and easier interaction with the PC operating system.</p>
                            <p>PC MiniApps are only available to those validated as an enterprise account. Most of the features are under strict regulations so that they can be considered highly trusted Web content.</p>
                        </dd>
                        <dt>PWAs</dt>
                        <dd>
                            <p>PWAs are the latest term to summarize modern Web applications. As a counterpart of native apps, a PWA looks and feels like a native app and can be installed on the device home screen/launcher/start menu; it can send push notifications to re-engage users; it can be used when offline and behaves under poor network conditions; it works with devices of wide-ranging capabilities, and it's still evolving to works with new capabilities defined by open Web standards; payments can be made by user inside PWAs apps; and PWAs apps are search-engine-friendly, working perfectly with hyperlinks. PWAs are successful in technical and business aspects (widely adopted by many websites, especially in consumer-facing ones).</p>
                        </dd>
                    </dl>
                </section> 
        </section>
        <section>
            <h2>Working with the Web</h2>
            <p>This section selects some typical use cases and proposes a few APIs that MiniApps would like to have support from the Web.</p>
            <section>
                <h2>Application Lifecycle</h2>
            <section>
                <h2>Hybrid Rendering</h2>
                <p>MiniApp is a hybrid solution of Web rendering and native rendering. It'd be great if there is a good way to combine the rendering results from the Web and the native.</p>
                <figure>
                    <img alt="Rendering results coming from both the Web and the native" src="images/rendering.png" width="600">
                    <figcaption>
                        Rendering results coming from both the Web and the native
                    </figcaption>
                </figure>
                <p>Proposal: MiniApp needs a standardized API to help integrate the native rendering result into the Web rendering outcome.</p>
            </section>
            <section>
            <h2>Transition Animation</h2>
                <p>MiniApp would like to provide transition animation during page switching so that users can have a similar experience as when they are using a native app, but it's almost impossible to do that now.</p>
                <p>Proposal: MiniApp needs an API to add transition animations during MiniApp page switching.</p>
            </section>
            <section>
            <h2>Standardise the Package Constructor of MiniApp</h2>
                <p>MiniApp can form a package and parsing convention for multiple MiniApp hosting platforms through a standardized distribution format. Currently, each MiniApp hosting platform provides different development tools (different packaging methods), and the MiniApp is parsed differently in different MiniApp hosting environments.</p>
                <p>Proposal: The MiniApp is actually a packaged (compressed) collection of files during the distribution process. We can describe a MiniApp (.ma) with a uniform file suffix and specify how to create the .ma file and how to parse the .ma file.</p>
            </section>
            <section>
            <h2>Standardise the navigation to a MiniApp page</h2>
                <p>For a hot page in a MiniApp, it may be referenced in another MiniApp, and it is expected to be accurately evoked when the user visits.</p>
                <p>Proposal: Define a standardized protocol (URI scheme) to access MiniApp.</p>
            </section>
            <section>
            <h2>MiniApp Widgets</h2>
                <p>Like Android widgets or Apple dashboard, users can directly get information and/or finish their task with a MiniApp widget without opening any Web or app pages. A MiniApp widget can be displayed in an environment outside of Web browsers, such as on desktops or dashboards.</p>
                <p>Proposal:</p>
                    <ul>
                        <li>A MiniApp widget can be displayed within a host environment, either a WebView or a native app page. The host environment loads a widget with its corresponding URI path, which describes a package and widget page.</li>
                        <li>A MiniApp widget can access local data or data from a server.  Meanwhile, a MiniApp widget can communicate with MiniApp in the same package.</li>
                        <li>A MiniApp widget should be interactive, meaning that it should be responsive to any user behaviors/interactions. A MiniApp widget should have the ability to open a Web or app page.</li>
                    </ul>
            </section>
            </section>

            <section>
                <h2>Performance and Tuning</h2>
            <section>
                <h2>Define an event for "time to interactive" in MiniApp</h2>
                <p>MiniApp needs to know when the MiniApp page Time to Interactive (TTI) has been completed.</p>
                <p>Proposal: A standardized event to notify that the MiniApp page Time to Interactive has been completed.</p>
            </section>
        </section>

        <section>
                <h2>Graphics and Media</h2>
            <section>
                <h2>3D Model Element</h2>
                <p>3D models have become more and more popular thanks to their rich details. Combined with AR, they will provide a better user experience than 2D. The business cases might include online shopping, advertisement, education, etc. However, the current Web lacks a standard and convenient way to deal with 3D models. In this document, we propose to define an HTML tag to directly handle 3D models, similar to the way we handle audio, video, and image with corresponding HTML tags:</p>
                    <ul>
                        <li>360 view
                            <p>Users can view a 3D model from different angles via gestures. And the 3D model can be zoomed in/out as well. It can be viewed on full screen or embedded in an webpage, shown together w/ other HTML contents.</p>
                        </li>
                        <li>View with AR
                            <p>Users can place the 3D model in the real world with the camera. Users can specify different locations to place the model.</p>
                        </li>
                    </ul>
                <p>Proposal: A <code>&lt;xmodel&gt;</code> element to specify a 3D model on the Web and power interactive 3D contents with AR.</p>
            </section>

            <section>
                <h2>Face Tracking</h2>
                <p>Face tracking can be used in many 3D scenarios.</p>
                <dl>
                        <dt>Face Effects in Live Video</dt>
                        <dd>
                            Add effects on the face in live video. These effects include a full-screen filter, face reshape and makeup, 2D sticker, 3D headdress, etc. Most of these effects depend heavily on real-time face tracking from a video source.
                        </dd>
                        <dt>Gaming</dt>
                        <dd>
                            Game developers can design game strategies based on the tracked face, like triggering a specific game logic when the eye blinks or checking if the dropping fruit is in the opened mouth.
                          </dd>
                        <dt>Virtual Makeup</dt>
                        <dd>
                          Let users try lipsticks, eye shadows, glasses, and hats on the product page to help them decide.
                        </dd>
                </dl><p>Proposal: A Face Tracking API use a video element as input and updates face tracking output every frame, which includes:
                    <ul>
                        <li>Bounding box of each face
                        </li>
                        <li>4x4 pose matrix of each face
                        </li>
                        <li>Normalized (x, y) landmarks points
                        </li>
                        <li>Face geometry data including vertices, normals, texture coordinates
                        </li>
                    </ul>
            </section>

            <section>
                <h2>Hand gestures tracking and recognition</h2>
                <p>Hand gestures can be used in video effects and AR/VR game scenarios to make apps more impressive and interactive.</p>
                <p>Proposal: A high-level API to track hand movement and get the hands outline.</p>
            </section>

            <section>
              <h2>Low level AR APIs based on ARCore and ARKit</h2>
              <p>There are a few AR APIs in MiniApps we would migrate to the Web, as they help provide a better AR experience in gaming, 3D model preview, and interactive ads.</p>
              <p>Proposal: Provide low-level AR APIs based on ARCore and ARKit, which include:</p>
              <dl>
              <dt>Camera view matrix for world tracking</dt>
              <dd>Provide the 4x4 view matrix of the spatial location and orientation of the mobile phone, which can be used to update the camera matrix in their 3D virtual world in real-time by developers. Thereby the position of the real world can be correlated with the position of the object in the virtual world.</dd>
              <dt>Plane detection and tracking</dt>
              <dd>Detect planes in the real world and track these planes in real-time. Provide the 4x4 transform matrix, which represents the center position and orientation of each plane. It can be used for placing 3D virtual objects on the ground/desktop.</dd>
              <dt>Anchor</dt>
              <dd>Anchor defines a fixed position and orientation in the real-world. Developers can create an anchor from a 4x4 transform matrix, which can be got by hit test. This matrix will be updated each frame to ensure that the virtual object corresponding to the matrix can be fixed in one position and direction in the real scene.</dd>
              <dt>Hit test</dt>
              <dd>Get a 4x4 transform matrix representing a position and orientation in the real world space corresponding to the screen position to implement functions such as clicking and placing virtual objects.</dd>
              </dl>
                <figure>
                    <img alt="Better support for AR" src="images/ar_support.png" width="600">
                    <figcaption>
                        APIs to better support AR
                    </figcaption>
                </figure>
            </section>
        </section>
        </section>

        <section>
          <h2>Current standards work; the WG work</h2>
          <section>
            <h2>Lifecycle</h2>
            <p>[[MINIAPP-LIFECYCLE]] defines the MiniApp lifecycle events and the process of managing MiniApp and each page's lifecycle. Implementing this specification enables the user agent to manage the lifecycle events of both the global application lifecycle and the page lifecycle.</p>

            <p>As described in [[[#separate-the-view-layer-from-the-logic-layer]]], in a MiniApp, the view layer is separated from the logic layer. The view layer is responsible for rendering MiniApp pages, including Web rendering and native rendering, which can be considered hybrid rendering. The logic layer is implemented with JavaScript Worker. The logic layer is responsible for MiniApp’s event processing, API calls, and lifecycle management.</p>

            <p>MiniApp lifecycle mechanism provides a means to manage MiniApp's view layer and logic layer through the MiniApp global application lifecycle events and MiniApp page lifecycle events. Developing MiniApp with knowledge of the MiniApp global application lifecycle states and MiniApp page lifecycle states can lead to improved user experiences. MiniApp lifecycle includes a set of events, with which MiniApp can choose to alter its behavior based on its state.</p>
          </section>

          <section>
            <h2>Manifest</h2>
            <p>[[MINIAPP-MANIFEST]] is the specification that defines the set of metadata to describe MiniApps. The MiniApp Manifest extends the [[APPMANIFEST]] and the [[MANIFEST-APP-INFO]] specifications by providing additional mechanisms to set up basic information of a MiniApp, like identification, human-readable descriptions, versioning data, and styling information. The MiniApp manifest also configures the routing of the pages and widgets that are part of a MiniApp. 
            </p>

            <p>A MiniApp manifest is a JSON document that uses some basic elements of the Web App Manifest to describe a MiniApp (<code>name</code>, <code>short_name</code>, <code>description</code>, and <code>icons</code>), adding nine supplementary members to specify technical details about the MiniApp (<code>app_id</code>, <code>version</code>, <code>platform_version</code>, <code>device_type</code>, <code>pages</code>, <code>req_permissions</code>, and <code>widgets</code>) and configure the look and feel of the app (<code>color_scheme</code> and <code>window</code>).
            </p>
          </section>

          <section>
            <h2>Packaging</h2>
            <p>[[MINIAPP-PACKAGING]] defines the semantics and conformance requirements for a MiniApp package and the structure of the container that holds the resources of a MiniApp, including the page components (i.e., templates, stylesheets, and JavaScript logic), the manifest, and other media files or configuration resources.
            </p>

            <p>This specification determines the logic and physical structures of MiniApps, holding the requirements in terms of file system organization and processing of the ZIP-based container that packs a MiniApp. Instances of the MiniApp package facilitate the MiniApp distribution and execution in runtime environments or MiniApp user agents.
            </p>
          </section>

          <section>
            <h2>Addressing</h2>
            <p>[[MINIAPP-ADDRESSING]] is a Note that defines a standard MiniApp protocol for accessing MiniApps. It aims to solve the problem that currently, each MiniApp vendor has its own way of describing a MiniApp resource and uses very different methods to obtain the MiniApp package, which makes it very difficult to access MiniApps across platforms and difficult to reach a unified understanding from both user and developer perspectives.</p>
            <p>The document refers to mobile deep linking technology and defines two ways to access MiniApp, one with the HTTPS protocol and the other with a custom protocol. In addition, MiniApp Addressing defines the syntax of MiniApp URIs, including uri-prefix for cross-environment access, uri-infix `"miniapp"` for MiniApps, and identifier and version to uniquely identify a MiniApp.</p>
            <p>MiniApp Addressing also describes how the user agent obtains the corresponding mini-app package based on MiniApp URI, as well as some error handling, and gives an example procedure for downloading MiniApp packages over the network. </p>
          </section>

          <section>
            <h2>Widget</h2>
            <p>MiniApp Widget is a special form of MiniApp Page. Same as a page, a widget runs in a host environment that is called the MiniApp user agent. Unlike a MiniApp page, a widget can occupy a certain area instead of the entire screen. The [[MINIAPP-WIDGET-REQ]] document describes the initial design considerations for developing a MiniApp Widget, including user agent, packaging, manifest, addressing, lifecycle, UI components, API, and communication between MiniApp and MiniApp Widget etc. The detailed Widget specification will be described in a separate document, which will describe the detailed technical requirement and capabilities of user agent. For example, the potential dependencies of widget running environment, the potential changes of API and UI Components brought by Widget, and new features bright by Widget such as the requirement of communication between MiniApp and MiniApp Widget. Both user agent developers and widget developers can refer to the Widget specification for technical development.
            </p>
          </section>

          <section>
            <h2>Implementation, converting tools</h2>
            <p>In 2021, the Working Group published two documents, [[MINIAPP-MANIFEST]] and [[MINIAPP-LIFECYCLE]]. Meanwhile, various vendors have some pre-standard implementations. To verify the feasibility of the standards and be compatible with pre-standard implementations, the working group developed a tool for converting MiniApp standard Manifest to different pre-standard manifest files, such as Baidu's <code>App.json</code> and HarmonyOS FA's <code>config.json</code>. And in a 2021 TPAC breakout session, the working group demonstrated a demo of the tool.</p>
            <p>As the standards and pre-deployment progress, the working group plans to refine the tools to support a complete, standardized development approach that may include Packaging, Addressing, Lifecycle, UI components, and APIs.
            </p>
          </section>

        </section>

        <section>
          <h2>New ideas incubated; the CG work</h2>
          <section>
            <h2>UI components</h2>
            <p>MiniApp components are the building blocks to define the structure, content, and logic of the pages that form a MiniApp. Each component encapsulates functionality, data, and styles, enabling developers to build reusable and customizable items.</p>
            <p>The MiniApp UI Components specification collects a set of essential elements that developers can use to build homogeneous but customized user interfaces across MiniApp platforms.</p>
            <p>This specification does not reference specific versions of HTML and CSS. It points to the latest W3C recommendations in order to guarantee the adoption and implementation of the changes to the HTML and CSS standards. Both MiniApp user agent vendors and developers will need to keep track of changes to these specifications to ensure that their processes and systems are kept up to date.</p>
            <p>This specification defines a set of predefined elements that are common in all the MiniApp specifications, based on Web Components.</p>
          </section>

          <section>
            <h2>MiniApps for IoT</h2>
            <p><a href="https://w3c.github.io/miniapp-iot">MiniApp for IoT</a> describes the use cases of MiniApp for IoT. Derived from the use cases, this specification defines the architecture of MiniApp for IoT. How to reuse and extend the MiniApp Packaging and MiniApp Lifecycle is specified. Also, several APIs are specified for MiniApp APIs for IoT.</p>

            <p>MiniApp for IoT has a similar architecture to MiniApps running on cell phones and PCs. But since IoT device has different hardware capabilities, MiniApp for IoT has its unique features, including:</p>

            <ul>
            <li>MiniApp Packaging for IoT</li>
            <li>MiniApp Lifecycle for IoT</li>
            <li>MiniApp APIs for IoT</li>
            </ul>
          </section>
        </section>

          <section>
                <h2>Security and Privacy Consideration</h2>
                <p>MiniApp utilizes HTTPS to support secure connections. Multiple MiniApps within the same host environment are independent of each other.</p>
                <p>User interactions within MiniApp need a different level of user permissions:
                </p>
                <table>
                      <tbody><tr>
                        <th>Permission</th>
                        <th>User Interactions</th>
                      </tr>
                      <tr>
                        <td>Default (no extra action needed)</td>
                        <td>Page sharing, clipboard, vibration, compass, motion sensors, map, screen brightness, screen capture, battery status</td> 
                      </tr><tr>
                        <td>Permission on first-time usage</td>
                        <td>Geolocation, camera(qr code), network status, Bluetooth, NFC</td> 
                      </tr><tr>
                        <td>Permission on every usage</td>
                        <td>Contacts, file-apis, add to home screen, photo picker, phone call</td> 
                      </tr><tr>
                        <td>Validate with token</td>
                        <td>Push</td> 
                      </tr><tr>
                        <td>Callback/messaging</td>
                        <td>Password-free Payment</td> 
                      </tr><tr>
                        <td>Request password</td>
                        <td>Payment</td> 
                      </tr>
                    </tbody>
                  </table>
                  <p>
                    From different perspectives and according to different security levels, the MiniApp framework provides the following methods.
                  </p>

                  <section>
                    <h2>Capability authentication</h2>
                    <p>
                      For capabilities with high privacy risks, MiniApp requires developers to apply for permission to use such features on the MiniApp developer platform. The application includes the rationale, a detailed description of the usage scenario, and the demo of usage. Then the platform will review applications according to the MiniApp usage requirements.  Only approved MiniApps are allowed to invoke such interfaces. For example, the ability to obtain the user's mobile phone number is one of the capabilities with high-security risks. 
                    </p>
                  </section>

                  <section>
                    <h2>
                      User Authorization
                    </h2>
                    <p>
                      For interfaces involving user privacy, the user's authorization must be required.  MiniApp classifies these sensible interfaces into several authorization <dfn>scopes</dfn> such as <em>location</em>, <em>album</em>, <em>address</em>, <em>camera</em>, <em>calendar</em>, etc. For example, a window will be popped up (see figure below) when the MiniApp tries to invoke the camera capability but users don't authorize it. Thus, users understand that such privacy-related feature is protected. Meanwhile, MiniApps hosted by different <a>super apps</a> might have some different privacy authorization <a>scopes</a> based on the usage characteristics and usage scenarios of each <a>super app</a>.
                    </p>
                    <figure>
                      <img alt="User Authorization" src="images/user_authorization.png" width="400">
                      <figcaption>
                        User authorization
                      </figcaption>
                    </figure>
                  </section>

                  <section>
                    <h2>
                      MiniApp Audit Review
                    </h2>
                    <p>
                      MiniApp packages will be reviewed by MiniApp platforms before publishing. Developers must follow MiniApp Platform Operation Terms because the platform is the only way for them to publish a new version MiniApp. There are many aspects of platform auditing, such as data collection, data use, data security, and geographic location.
                    </p>
                  </section>

                  <section>
                    <h2>
                      Domain check
                    </h2>
                    <p>
                      For some container components, like <code>&lt;web-view&gt;</code>, that could render online webpages, MiniApp user agents may limit the URLs accessed by the component. Only the domain configured in the MiniApp Management Center can be accessed in <code>&lt;web-view&gt;</code>. Also, if the component contains an <code>&lt;iframe&gt;</code>, the URL opened by the `iframe` should also be configured in the MiniApp Management Center. In this way, MiniApp platforms can have more robust control over the dynamic pages opened by the MiniApp.
                    </p>
                    <p>
                      Similarly, the MiniApp framework verifies the legitimacy of the asynchronous request address.
                    </p>
                    <p>
                      For example, for URLs launched by request, download, upload, etc., their domain must belong to the domain configured in the MiniApp Management Center, and their protocols must be HTTPS protocols to ensure the security of data transmission.
                    </p>
                  </section>
            </section>

            <section>
              <h2>MiniApp Standardization in the Globe</h2>
              <p>
                Though it originated in China, MiniApp is increasing in popularity around the globe. Similar product forms are raised in other parts of the world, including Japan, Korea, Southeast Asia, the US, Europe, and Africa. The standardization of MiniApp technologies has drawn considerable attention from the global Web community. Thus, the collaboration on MiniApp standards becomes a joint international effort.
              </p>
              <section>
                <h2>Broader Web Community Discussions on MiniApp</h2>
                <p>The first global Web community discussion on MiniApp standardization was during <a href="https://www.w3.org/2019/09/TPAC/">TPAC 2019</a> in Fukuoka. A <a href="https://www.w3.org/2019/09/18-miniapp-minutes.html">breakout session</a> was organized during which MiniApp vendors introduced MiniApp technologies and the necessity for MiniApp standards. The participants discussed the possible directions for MiniApp standardizing, such as packaging, manifest, lifecycle, and widget. Special efforts were made to avoid the overlapping between MiniApp standards and the current Web standards efforts and enhance the interoperability between MiniApp platforms and the Web and between different MiniApp platforms. The <a href="https://www.w3.org/community/miniapps/">MiniApps Ecosystem Community Group</a> was launched right after this discussion, and the incubation of MiniApp specifications started.</p>
                <p>During virtual <a href="https://www.w3.org/2020/10/TPAC/">TPAC 2020</a>, there was a breakout session titled <i><a href="https://www.w3.org/2020/10/28-miniappslearnings-minutes.html">Learning from Mini Apps</a></i> at the event. In this breakout session, experts discussed the abstract form of a MiniApp and the powerful features that MiniApps can have. Also, the session shared how one could build a MiniApp via various development tools. Then there was an open discussion focused on what Web developers can learn from MiniApp and their developer experience. </p>
              </section>

              <section>
                <h2>MiniApp in CJK</h2>
                <p>
                  MiniApp product forms and technologies in Asian markets share lots of similarities. To gather the global community, especially the Chinese, Japanese and Korean participants, to communicate around the MiniApp ecosystem in each area and discuss the future of standardization efforts on MiniApps, W3C <a href="https://www.w3.org/2021/miniapps/">MiniApps Working Group</a>, and <a href="https://www.w3.org/community/miniapps/">MiniApps Ecosystem Community Group</a> organized <a href="https://www.w3.org/2021/03/miniapp-cjk/index.html">the 1st CJK Meeting on MiniApps</a> in April 2021. About 90 participants from over 30 organizations joined the discussion and exchanged ideas about MiniApp ecosystems, technical architecture, frameworks and MiniApps in new scenarios such as MiniApp for vehicles. A rough conclusion about the discussion is that as the development of MiniApp standards go on well in the MiniApps Working Group, it’s time to start the horizontal review of security, privacy, accessibility as well as internationalization of MiniApp standards; also, leveraging IoT technologies in MiniApp can be a very promising direction for the for MiniApp in new scenarios and there will be good opportunity for the global MiniApp community to cooperate on the related standardization work. 
                </p>
              </section>

              <section>
                <h2>MiniApps in Europe</h2>
                  <p>Although there are only a few cases of MiniApps in Europe, this concept is gaining traction; and the community has started to explore these technologies, looking for new business models and innovations out of the traditional app marketplaces.</p>
                  <p>In 2021, a group of stakeholders, including three W3C Members, launched the <a rel="nofollow" href="https://quick-app-initiative.ow2.io/">Quick App Initiative</a>, an open-source-oriented interest group open to any organization and individual and driven by open collaboration. This group, hosted by OW2, an independent non-profit organization based in France, is ruled under a transparent process intending to promote the W3C works from a vendor-neutral perspective and focused on outreach, implementations, and standardization requirements gathering from the European market perspective.</p>
              </section>

            </section>

            <section>
                <h2>Way Forward in W3C</h2>
                <p>To meet the use cases and requirements of MiniApps, make the Web standards better support the MiniApp, explore the innovation of user agents, and enrich the Web, we hope to set up a group and include the following work in W3C:</p><ul>
                        <li>Coordinate the MiniApp-related standardization in W3C as well as to collaborate with other related W3C groups.
                        </li>
                        <li>Horizontal review (i.e., security, privacy, <abbr title="internationalization">i18n</abbr>, and <abbr title="accessibility">a11y</abbr>).
                        </li>
                    </ul>

                    <p>In detail, the following technical work shall be studied further:</p><ul>
                        <li>Draft a roadmap for MiniApp standards based on the use cases and requirements selected by the group.
                        </li>
                        <li>Develop specifications for features among current vendors. Target features include but are not limited to:
                            <ul>
                        <li>Package constructor</li>
                        <li>MiniApp URI scheme</li>
                        <li>Hybrid rendering API</li>
                        <li>3D model element</li>
                        <li>Face tracking API </li>
                        <li>Widget</li>
                    </ul>
                        </li>
                        <li>design future Web APIs to be useful for both Web and MiniApp environments.</li>
                    </ul>
                 <p>Note: the further gap between current MiniApp APIs and Web APIs will be analyzed in parallel.</p>
            </section>

            <section id="glossary">
                <h2>Glossary</h2>
                <table class="glossary">
                  <thead>
                      <tr>
                        <th>Chinese</th>
                        <th>English</th>
                        <th>Definition</th>
                      </tr>
                    </thead>
                      <tbody>
                      <tr id="term.mini-program">
                        <td lang="zh">小程序</td>
                        <td>Mini Program</td> 
                        <td>One format of MiniApp running within native apps.</td> 
                      </tr>
                      <tr id="term.quick-app">
                        <td lang="zh">快应用</td>
                        <td>Quick App</td>
                        <td>A MiniApp standard developed by 12 mobile phone manufacturers in Quick App alliances.</td> 
                      </tr>
                      <tr id="term.rendering-view">
                        <td lang="zh">渲染环境</td>
                        <td>rendering view</td>
                        <td>Native view or WebView.</td>
                      </tr>
                      <tr id="term.smart-assistant">
                        <td lang="zh">智能助理（负一屏）</td>
                        <td>smart assistant</td> 
                        <td>A smart assistant to provide service for convenience, usually at left of the home screen.</td> 
                      </tr>
                      <tr id="term.hot-reload">
                        <td lang="zh">热更新</td>
                        <td>hot reload</td>
                        <td>No need to be re-installed when fixing or updating feature. In MiniApps, since a part of framework is implemented in JavaScript, MiniApp runtime can be hot reloaded.</td>
                      </tr>
                    </tbody></table>
            </section>

    <section class="appendix">
      <h2>
        Gap Analysis
      </h2>
      <p>
        Please look at <a href="comparison.html">the comparison table of APIs in MiniApps, W3C specs, and PWAs</a>.
      </p>
    </section>

            <section class="appendix">
      <h2>
        Acknowledgments
      </h2>
      <p>
        Many thanks to Guanyu Liu (360), He Du (Xiaomi), Hongguang Dong (Xiaomi), Xiaoqian Wu (W3C), Yi Shen (Baidu), Yefeng Xia (China Mobile) who also contributed to this document.
      </p>
    </section>
</body>

</html>
